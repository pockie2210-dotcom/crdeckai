<!DOCTYPE html>
<!-- Build: 2026-01-18-v1 - Improve Deck Fix -->
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Clash Royale Deck Helper</title>
  <link rel="stylesheet" href="style.css">
  <style>
    /* small inline spacing fix for demo button */
    .card .actions {
      display: flex;
      gap: 12px;
      justify-content: center;
      align-items: center;
    }

    /* Swap Modal */
    #swapModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .swap-content {
      background: #1a1a1a;
      padding: 20px;
      border-radius: 12px;
      border: 2px solid var(--gold);
      max-width: 600px;
      width: 90%;
      text-align: center;
    }

    .swap-options {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .swap-card {
      cursor: pointer;
      position: relative;
      transition: transform 0.2s, border-color 0.2s;
      border: 2px solid transparent;
      border-radius: 8px;
      padding: 5px;
      background: #222;
    }

    .swap-card:hover {
      transform: scale(1.05);
      border-color: var(--accent);
    }

    .swap-score {
      position: absolute;
      top: -10px;
      right: -10px;
      background: var(--gold);
      color: black;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 12px;
    }

    /* Strategy Guide */
    #strategyGuide {
      background: #1e1e1e;
      border: 1px solid var(--gold);
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
      border-radius: 8px;
      padding: 20px;
      margin-top: 25px;
      display: none;
      line-height: 1.6;
      font-size: 1rem;
    }

    #strategyGuide h3 {
      margin-top: 0;
      color: var(--gold);
      font-size: 1.3rem;
      border-bottom: 1px solid #444;
      padding-bottom: 10px;
      margin-bottom: 15px;
    }

    /* Force Paragraphs to be BIG */
    #strategyGuide p {
      margin-bottom: 15px;
      color: #ddd;
    }

    #strategyGuide strong {
      color: var(--accent);
    }

    /* Playstyle Selector */
    .playstyle-btn {
      padding: 12px 20px;
      border: 2px solid transparent;
      border-radius: 8px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 14px;
    }

    .playstyle-btn:hover {
      transform: scale(1.05);
      border-color: var(--gold);
    }

    .playstyle-btn.active {
      border-color: var(--gold);
      box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
    }

    /* WIN CONDITION GUIDE MODAL */
    #winConditionModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .guide-content {
      background: #1a1a1a;
      padding: 25px;
      border-radius: 12px;
      border: 2px solid var(--gold);
      max-width: 700px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      text-align: center;
    }

    .guide-block {
      background: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      border-left: 3px solid var(--accent);
    }

    /* ROLE CARD VISUALS */
    .role-grid-container {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      justify-items: center;
      margin-bottom: 25px;
      max-width: 400px;
      /* 4 * 80px card + gaps ~ 400px is safe */
      margin-left: auto;
      margin-right: auto;
    }

    .role-card {
      width: 80px;
      height: 100px;
      border-radius: 12px;
      border: 3px solid #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Arial Black', sans-serif;
      /* Impact/Thick font */
      font-size: 28px;
      color: white;
      text-shadow:
        2px 2px 0 #000,
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000;
      cursor: pointer;
      transition: transform 0.2s, filter 0.2s;
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.5);
      /* 3D effect */
    }

    .role-card:hover {
      transform: translateY(-5px);
      filter: brightness(1.2);
    }

    .role-card.selected {
      border-color: white;
      box-shadow: 0 0 15px white;
    }

    #roleDetailArea {
      min-height: 120px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      padding: 15px;
      border: 1px solid var(--gold);
      margin-bottom: 20px;
      display: none;
      /* Hidden until clicked */
    }

    /* SELECTION GRID (Win Condition Menu) */
    #winConditionGrid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 15px;
      padding: 10px;
      max-width: 800px;
      margin: 0 auto;
    }

    .win-con-card {
      position: relative;
      cursor: pointer;
      border-radius: 6px;
      overflow: hidden;
      transition: transform 0.2s, box-shadow 0.2s;
      border: 2px solid #333;
      background: #111;
      aspect-ratio: 0.8;
      /* Card shape */
    }

    .win-con-card:hover {
      transform: scale(1.05);
      border-color: var(--gold);
      box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
    }

    .win-con-card img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .win-con-label {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      font-size: 11px;
      padding: 4px;
      text-align: center;
      font-weight: bold;
      pointer-events: none;
    }
  </style>
</head>

<body>

  <!-- SWAP MODAL -->
  <div id="swapModal">
    <div class="swap-content">
      <h2 style="color:var(--gold); margin-bottom:10px;">Select Replacement</h2>
      <p style="color:#ccc;">Here are the best alternatives for this slot:</p>
      <div id="swapOptions" class="swap-options"></div>
      <button onclick="document.getElementById('swapModal').style.display='none'" class="action-btn"
        style="background:#555; margin-top:20px;">Cancel</button>
    </div>
  </div>

  <!-- SUBSTITUTIONS MODAL -->
  <div id="substitutionsModal"
    style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:2000; align-items:center; justify-content:center;">
    <div class="swap-content"
      style="max-width:800px; width:90%; max-height:90vh; overflow-y:auto; display:flex; flex-direction:column;">
      <h2 style="color:var(--gold); margin-bottom:5px;">Substitutions Manager</h2>
      <p style="color:#ccc; margin-bottom:20px;">Select a card you want to ADD to your deck. The AI will suggest the
        best replacement.</p>

      <div style="margin-bottom:15px;">
        <input id="subSearch" placeholder="Search cards..."
          style="padding:10px; width:100%; border-radius:8px; border:1px solid #555; background:#222; color:white;">
      </div>

      <div id="subsGrid" class="picker-grid" style="flex:1; overflow-y:auto; min-height:300px;">
        <!-- Filled by JS -->
      </div>

      <button onclick="document.getElementById('substitutionsModal').style.display='none'" class="action-btn"
        style="background:#555; margin-top:20px;">Cancel</button>
    </div>
  </div>

  <!-- WIN CONDITION GUIDE MODAL -->
  <div id="winConditionModal">
    <div class="guide-content">
      <div id="guideList">
        <h2 style="color:var(--gold); margin-bottom:10px;">Win Condition Masterclass</h2>
        <p style="color:#ccc; margin-bottom:20px;">Select a Win Condition to learn how to master it.</p>
        <div id="winConditionGrid" class="picker-grid"></div>
        <button onclick="document.getElementById('winConditionModal').style.display='none'" class="action-btn"
          style="background:#555; margin-top:20px;">Close</button>
      </div>

      <div id="guideDetail" style="display:none; text-align: left;">
        <button id="backToGuideList" class="action-btn" style="background:#444; margin-bottom:15px;">&larr;
          Back</button>
        <h2 id="guideTitle" style="color:var(--gold); margin-top:0;">Title</h2>
        <div id="guideBody"></div>
      </div>
    </div>
  </div>

  <h1>Player tag (insert player tag) <span style="font-size:12px; color:#aaa;">v2.1 (Fix)</span></h1>

  <div class="card">
    <input id="tagInput" placeholder="#PLAYER TAG">
    <br><br>
    <div class="actions">
      <button id="scanBtn">Scan Player</button>
      <button id="canImproveDeckBtn" style="display:none; background: #27ae60;">Improve Deck</button>
      <button id="substitutionsBtn" style="display:none; background: #9b59b6;">Substitutions</button>
      <!-- Weakness Check button (Renamed & Restored) -->
      <button id="weaknessReportBtn" style="display:none; background: #c0392b;">Weakness Check</button>
      <button id="synergyBtn"
        onclick="if(window.currentAppDeck) window.SynergyMatrix.render(window.currentAppDeck); else alert('Scan a player first!');"
        style="background: #2980b9;">&#128279; Synergy
        Matrix</button>
      <button id="radarBtn"
        onclick="if(window.currentAppDeck) window.DeckRadar.render(window.currentAppDeck); else alert('Scan a player first!');"
        style="background: #e67e22; margin-left:5px;">&#128202; Deck Radar</button>
      <button id="buildBtn" style="display:none; background: linear-gradient(135deg, #e67e22, #d35400);">Build
        Deck</button>
      <button id="demoBtn">Show Demo Deck</button>
    </div>
    <div id="statsContainer" class="stats"></div>
    <div id="deckContainer" class="deck"></div>
    <div id="builderControls" style="display:none; margin-top: 20px;">

      <!-- Live Stats Panel -->
      <div id="statsPanel" class="stats-panel" style="display:none;">
        <div class="badge-score" id="metaScoreBadge">Meta Score: --</div>

        <!-- EXTERNAL DECK CHECK -->
        <button id="checkDeckBtn" class="action-btn"
          style="width:100%; margin-top:10px; background: #34495e; border: 1px solid #7f8c8d;">
          ðŸ” Verification Check (DeckShop)
        </button>

        <div id="deckCheckResult"
          style="margin-top:10px; font-size:12px; display:none; padding:10px; background:rgba(0,0,0,0.6); border-radius:8px;">
        </div>

        <!-- NEW: Predicted Win Rate -->
        <div
          style="margin: 15px 0; padding: 15px; background: linear-gradient(135deg, rgba(46, 204, 113, 0.2), rgba(0, 0, 0, 0.3)); border: 2px solid rgba(46, 204, 113, 0.5); border-radius: 10px; text-align: center;">
          <div style="color: #2ecc71; font-size: 14px; font-weight: bold; margin-bottom: 5px;">ðŸ“Š PREDICTED WIN RATE
          </div>
          <div id="winRateDisplay"
            style="font-size: 32px; font-weight: 900; color: #2ecc71; text-shadow: 0 0 10px rgba(46, 204, 113, 0.5);">--
          </div>
          <div id="winRateFactors" style="font-size: 11px; color: #95a5a6; margin-top: 5px;">Calculating...</div>
        </div>

        <div>
          <div class="stat-row"><span>âš”ï¸ Offense</span> <span id="offScore" class="stat-score">0</span></div>
          <div class="stat-bar-bg">
            <div id="offBar" class="stat-bar-fill" style="width:0%; background:#e74c3c"></div>
          </div>
        </div>

        <div>
          <div class="stat-row"><span>ðŸ›¡ï¸ Defense</span> <span id="defScore" class="stat-score">0</span></div>
          <div class="stat-bar-bg">
            <div id="defBar" class="stat-bar-fill" style="width:0%; background:#3498db"></div>
          </div>
        </div>

        <div>
          <div class="stat-row"><span>ðŸ¤ Synergy</span> <span id="synScore" class="stat-score">0</span></div>
          <div class="stat-bar-bg">
            <div id="synBar" class="stat-bar-fill" style="width:0%; background:#9b59b6"></div>
          </div>
        </div>

        <div>
          <div class="stat-row"><span>&#128260; Avg Elixir</span> <span id="avgElixir" class="stat-score">--</span>
          </div>
          <div class="stat-row"><span>&#9889; 4-Card Cycle</span> <span id="cycleCost" class="stat-score">--</span>
          </div>
        </div>
      </div>

      <!-- NEW STRATEGY SECTION - Enhanced -->
      <div id="strategyGuide"
        style="display:none; background:linear-gradient(135deg, rgba(123, 63, 228, 0.2), rgba(0,0,0,0.7)); margin-top:25px; padding:25px; border-radius:12px; border-left: 4px solid var(--gold); border: 2px solid rgba(212, 175, 55, 0.3); box-shadow: 0 4px 16px rgba(0,0,0,0.4); color:#ecf0f1; font-size:15px; line-height:1.8;">
        <!-- AI Content Goes Here -->
      </div>

      <!-- PLAYSTYLE SELECTOR -->
      <div
        style="margin-top:20px; padding:15px; background:rgba(0,0,0,0.4); border-radius:8px; border:1px solid var(--gold);">
        <h3 style="color:var(--gold); margin-top:0;">Choose Your Playstyle</h3>
        <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
          <button class="playstyle-btn" data-style="any" style="background:#555;">ðŸŽ² Any</button>
          <button class="playstyle-btn" data-style="cycle" style="background:#3498db;">âš¡ Cycle</button>
          <button class="playstyle-btn" data-style="control" style="background:#9b59b6;">ðŸ›¡ï¸ Control</button>
          <button class="playstyle-btn" data-style="beatdown" style="background:#e74c3c;">ðŸ˜ Beatdown</button>
          <button class="playstyle-btn" data-style="bridgespam" style="background:#e67e22;">ðŸš€ Bridge Spam</button>
          <button class="playstyle-btn" data-style="bait" style="background:#27ae60;">ðŸª¤ Log Bait</button>
          <button class="playstyle-btn" data-style="siege" style="background:#2c3e50;">ðŸ¹ Siege</button>
          <button class="playstyle-btn" data-style="graveyard" style="background:#8e44ad;">ðŸ’€ Graveyard</button>
          <button class="playstyle-btn" data-style="miner" style="background:#16a085;">â›ï¸ Miner</button>
        </div>
      </div>

      <h3 style="color:var(--gold); margin-top:15px;">Choose Cards from Collection</h3>
      <p style="color:#aaa; font-size:12px; margin-top:5px;">Left-click to add â€¢ Right-click to exclude ðŸš«</p>
      <div id="cardPicker" class="picker-grid"></div>
      <button id="autofillBtn" class="action-btn" style="background:#8e44ad; margin-top:20px;">âœ¨ Auto-Complete
        Deck</button>
      <div id="aiStatus" style="font-size:12px; color:#ccc; margin-top:5px; height:1.2em;"></div>
    </div>
    <pre id="output" style="display:none; white-space: pre-wrap;"></pre>

    <!-- NEW WIN CONDITION BUTTON - ALWAYS VISIBLE AT BOTTOM -->
    <div
      style="margin-top: 40px; text-align: center; padding-bottom: 20px; display: flex; gap: 20px; justify-content: center;">
      <button id="winConGuideBtn" class="action-btn"
        style="background: linear-gradient(135deg, #1abc9c, #16a085); padding: 15px 30px; font-size: 18px; border: 2px solid #1abc9c;">
        &#127891; Win Condition Masterclass
      </button>
      <button id="matchupBtn" class="action-btn"
        style="background: linear-gradient(135deg, #e74c3c, #c0392b); padding: 15px 30px; font-size: 18px; border: 2px solid #e74c3c;">
        âš”ï¸ Matchup Analyzer
      </button>
      <!-- Weakness Check button is now in the main actions bar -->
    </div>


  </div>

  <!-- MATCHUP MODAL -->
  <div id="matchupModal" class="modal-overlay" style="display:none; align-items:flex-start; padding-top:50px;">
    <div class="modal-content" style="width: 90%; max-width: 900px; max-height: 90vh; overflow-y: auto;">
      <h2 style="color:var(--gold); display:flex; justify-content:space-between;">
        <span>âš”ï¸ Matchup Analyzer</span>
        <span id="closeMatchup" style="cursor:pointer;">&times;</span>
      </h2>
      <p style="color:#ccc; margin-bottom:20px;">Compare your current deck against an enemy deck.</p>

      <div style="display:flex; flex-wrap:wrap; gap:20px;">
        <!-- YOUR DECK (Read Only) -->
        <div style="flex:1; min-width:300px;">
          <h3 style="color:#2ecc71;">Your Deck</h3>
          <div id="myDeckPreview"
            style="display:grid; grid-template-columns:repeat(4, 1fr); gap:5px; pointer-events:auto; opacity:1;">
            <!-- Synergy Modal -->
            <div id="synergyModalMatchup" class="modal">
              <div class="modal-content"
                style="background:rgba(10, 10, 20, 0.95); border:1px solid #00d2ff; box-shadow:0 0 50px rgba(0, 210, 255, 0.2);">
                <span class="close"
                  onclick="document.getElementById('synergyModalMatchup').style.display='none'">&times;</span>
                <div id="synergyContentMatchup"></div>
              </div>
            </div>

            <!-- Builder Mode & Modal Script -->
          </div>
        </div>

        <!-- VS -->
        <div
          style="display:flex; align-items:center; justify-content:center; font-size:30px; font-weight:bold; color:#aaa;">
          VS
        </div>

        <!-- ENEMY DECK (Editable) -->
        <div style="flex:1; min-width:300px;">
          <h3 style="color:#e74c3c;">Enemy Deck</h3>
          <div id="enemyDeckWrapper"
            style="display:grid; grid-template-columns:repeat(4, 1fr); gap:5px; border: 2px dashed #444; padding:10px; min-height:100px;">
            <!-- Enemy Cards -->
          </div>
          <button id="clearEnemyBtn"
            style="margin-top:10px; padding:5px 10px; background:#444; border:none; color:#fff; cursor:pointer;">Clear
            Enemy Deck</button>
        </div>
      </div>

      <!-- ENEMY CARD PICKER -->
      <div style="margin-top:20px;">
        <h4 style="color:#aaa;">Add Enemy Cards:</h4>
        <div id="enemyCardPicker" class="picker-grid" style="max-height:200px; overflow-y:auto; border:1px solid #444;">
          <!-- Re-use picker logic -->
        </div>
      </div>

      <div style="margin-top:30px; text-align:center;">
        <button id="analyzeBtn" class="action-btn"
          style="background:var(--gold); color:#000; font-weight:bold; font-size:1.2em; padding:15px 40px;">
          âš–ï¸ Analyze Matchup
        </button>
      </div>

      <!-- RESULTS AREA -->
      <div id="analysisResult"
        style="display:none; margin-top:30px; background:rgba(0,0,0,0.5); padding:20px; border-radius:8px;">
        <h3 id="resultTitle" style="text-align:center; font-size:2em; margin-bottom:10px;">Even Matchup</h3>
        <div class="stat-bar-bg" style="height:20px; margin-bottom:20px;">
          <div id="advantageBar" class="stat-bar-fill" style="width:50%; background:#aaa; transition: width 0.5s;">
          </div>
        </div>

        <div style="display:flex; gap:20px; flex-wrap:wrap;">
          <div style="flex:1;">
            <h4 style="color:#e74c3c;">âš ï¸ Threats</h4>
            <ul id="threatList" style="list-style:none; padding:0; color:#ddd;"></ul>
          </div>
          <div style="flex:1;">
            <h4 style="color:#f1c40f;">ðŸ§  Strategy Tips</h4>
            <ul id="tipList" style="list-style:none; padding:0; color:#ddd;"></ul>
          </div>
        </div>
      </div>

    </div>
  </div>





  <!-- WEAKNESS MODAL -->
  <div id="weaknessModal" class="modal-overlay"
    style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; z-index:2100; background:rgba(0,0,0,0.85); align-items:center; justify-content:center;">
    <div class="guide-content"
      style="text-align:center; display:flex; flex-direction:column; width:95%; max-width:1000px; max-height:90vh; background:#1e1e1e; border:1px solid #444; padding:0;">

      <!-- HEADER -->
      <div style="padding:20px; border-bottom:1px solid #333;">
        <h2 style="color:var(--gold); margin:0; font-size:24px;">Deck Weakness Report</h2>
      </div>

      <!-- CONTENT GRID -->
      <div style="display:flex; flex:1; overflow:visible; flex-wrap:wrap;">

        <!-- LEFT: SCORE & RADAR -->
        <div
          style="flex:1; min-width:300px; background:rgba(0,0,0,0.2); display:flex; flex-direction:column; align-items:center; justify-content:center; padding:20px; border-right:1px solid #333;">
          <div id="weaknessScore">
            <!-- Injected via JS -->
          </div>
        </div>

        <!-- RIGHT: TEXT REPORT -->
        <div id="weaknessBody"
          style="flex:1.5; min-width:300px; padding:25px; text-align:left; color:#ddd; overflow-y:auto;">
          <!-- Results here -->
        </div>
      </div>

      <!-- FOOTER -->
      <div id="weaknessFooter" style="padding:15px; border-top:1px solid #333; background:#252525;">
        <button onclick="document.getElementById('weaknessModal').style.display='none'" class="action-btn"
          style="background:#555; padding:10px 30px;">Close Report</button>
      </div>
    </div>
  </div>

  <!-- SYNERGY MODAL -->
  <div id="synergyModal" class="modal-overlay"
    style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; z-index:2100; background:rgba(0,0,0,0.85); align-items:center; justify-content:center;">
    <div class="guide-content"
      style="text-align:center; display:flex; flex-direction:column; width:95%; max-width:800px; max-height:90vh; background:#1e1e1e; border:1px solid #444; padding:0; position:relative;">

      <!-- HEADER -->
      <div style="padding:20px; border-bottom:1px solid #333;">
        <h2 style="color:#00d2ff; margin:0; font-size:24px; text-shadow:0 0 15px rgba(0,210,255,0.4);">Synergy Matrix
        </h2>
      </div>

      <!-- CONTENT -->
      <div id="synergyContent"
        style="flex:1; padding:20px; overflow-y:auto; display:flex; align-items:center; justify-content:center;">
        <!-- Injected via JS -->
      </div>

      <!-- FOOTER -->
      <div style="padding:15px; border-top:1px solid #333; background:#252525;">
        <button onclick="document.getElementById('synergyModal').style.display='none'" class="action-btn"
          style="background:#555; padding:10px 30px;">Close Matrix</button>
      </div>
    </div>
  </div>

  <script src="meta_decks.js?v=4"></script>
  <script src="smart_ai.js?v=4"></script>
  <script>
    // --- GLOBAL HELPERS FOR DECK WEAKNESS ---
    // Moved here to ensure they are accessible by DeckWeakness logic

    // Role Definitions
    const ROLES = {
      winCon: ['Hog Rider', 'Royal Giant', 'Golem', 'Lava Hound', 'Balloon', 'Goblin Barrel', 'Miner', 'Graveyard', 'X-Bow', 'Mortar', 'Electro Giant', 'Goblin Giant', 'Ram Rider', 'Battle Ram', 'Wall Breakers', 'Elixir Golem', 'Skeleton Barrel', 'Three Musketeers', 'Giant'],
      spellSmall: ['The Log', 'Zap', 'Giant Snowball', 'Arrows', 'Barbarian Barrel', 'Tornado', 'Royal Delivery', 'Rage'],
      spellBig: ['Fireball', 'Poison', 'Rocket', 'Lightning', 'Earthquake', 'Void', 'Freeze'],
      airDefense: ['Musketeer', 'Electro Wizard', 'Wizard', 'Witch', 'Executioner', 'Hunter', 'Baby Dragon', 'Inferno Dragon', 'Mega Minion', 'Minions', 'Minion Horde', 'Bats', 'Spear Goblins', 'Ice Wizard', 'Princess', 'Dart Goblin', 'Magic Archer', 'Flying Machine', 'Firecracker', 'Mother Witch', 'Skeleton Dragons', 'Phoenix', 'Archer Queen', 'Little Prince'],
      building: ['Cannon', 'Tesla', 'Inferno Tower', 'Bomb Tower', 'Tombstone', 'Goblin Cage', 'Furnace', 'Barbarian Hut', 'Goblin Hut', 'Elixir Collector', 'Mortar', 'X-Bow'],
      miniTank: ['Mini P.E.K.K.A', 'P.E.K.K.A', 'Inferno Tower', 'Inferno Dragon', 'Hunter', 'Elite Barbarians', 'Prince', 'Lumberjack', 'Barperians', 'Skeleton Army', 'Guards']
    };

    function getCardRole(cardName) {
      let foundRoles = [];
      for (const [role, cards] of Object.entries(ROLES)) {
        if (cards.includes(cardName)) foundRoles.push(role);
      }
      return foundRoles.length > 0 ? foundRoles : ['troop'];
    }

    // Expose helpers globally
    window.getCardRole = getCardRole;
    window.ROLES = ROLES;

    // META QUALITY TIER LIST (Global)
    const META_QUALITY = {
      // S+ Tier Spells (Meta Staples) - BOOSTED
      'The Log': 150, 'Fireball': 140, 'Poison': 130, 'Tornado': 140,
      'Zap': 145, 'Arrows': 110, 'Lightning': 125, 'Earthquake': 120,
      'Barbarian Barrel': 125, 'Snowball': 120, 'Giant Snowball': 120,

      // S Tier Win Conditions (Reliable Damage Dealers) - BOOSTED
      'Hog Rider': 135, 'Miner': 140, 'Royal Giant': 120, 'Goblin Barrel': 130,
      'Wall Breakers': 125, 'Graveyard': 130, 'X-Bow': 120, 'Mortar': 110,
      'Goblin Drill': 125, 'Ram Rider': 115, 'Battle Ram': 105,

      // S Tier Support (Universal Utility) - BOOSTED
      'Knight': 150, 'Musketeer': 140, 'Ice Spirit': 145, 'Skeletons': 150,
      'Electro Spirit': 140, 'Valkyrie': 130, 'Baby Dragon': 130,
      'Electro Wizard': 140, 'Mega Minion': 125, 'Bats': 135,
      'Ice Golem': 120, 'Archers': 125, 'Flying Machine': 115,

      // A Tier (Strong Meta Picks)
      'Goblin Gang': 100, 'Cannon': 115, 'Tesla': 125,
      'Inferno Tower': 120, 'Lumberjack': 105, 'Magic Archer': 110,
      'Dark Prince': 95, 'Hunter': 50, 'Firecracker': 115,
      'Mini P.E.K.K.A': 120, 'Prince': 105, 'Bandit': 110,
      'Fisherman': 100, 'Mother Witch': 110, 'Royal Delivery': 100,
      'Dart Goblin': 110, 'Princess': 105, 'Minions': 105,

      // B Tier (Archetype-Specific Strong)
      'Giant': 80, 'Golem': 75, 'Lava Hound': 75, 'Balloon': 90,
      'Royal Hogs': 85, 'P.E.K.K.A': 85, 'Mega Knight': 75,
      'Sparky': 65, 'Executioner': 75, 'Bowler': 75,
      'Phoenix': 85, 'Electro Giant': 70, 'Goblin Giant': 75,
      'Night Witch': 90, 'Witch': 30, 'Royal Ghost': 85,
      'Inferno Dragon': 100, 'Skeleton Dragons': 85,

      // C Tier (Needs Specific Synergy)
      'Bomber': 50, 'Giant Skeleton': 35, 'Skeleton Army': 55,
      'Minion Horde': 50, 'Tombstone': 65, 'Rocket': 75,
      'Barbarians': 65, 'Elite Barbarians': 40, 'Royal Recruits': 75,
      'Rascals': 65, 'Guards': 70, 'Spear Goblins': 55,
      'Zappies': 50, 'Bomb Tower': 70, 'Goblin Cage': 80,

      // D/F Tier
      'Wizard': -80, 'Goblin Hut': -100, 'Furnace': -80,
      'Barbarian Hut': -200, 'Mirror': -220, 'Clone': -240,
      'Elixir Golem': -300, 'Battle Healer': -200, 'Three Musketeers': -180,
      'Rage': -100, 'Freeze': 50, 'Heal Spirit': 80,
      'Elixir Collector': 35, 'Void': 100
    };
    window.META_QUALITY = META_QUALITY; // Expose explicit

    const DeckWeakness = {
      /**
       * Analyzes a deck and returns a health report.
       * @param {Array} deck - Array of card objects {name, ...}
       * @returns {Object} { health: number, issues: [], suggestions: [] }
       */
      detect: function (deck) {
        if (!deck || deck.length !== 8) {
          return {
            health: 0,
            issues: ["Deck must have exactly 8 cards."],
            suggestions: ["Finish building your deck first!"]
          };
        }

        const report = {
          health: 100,
          issues: [],
          suggestions: []
        };

        const cardNames = deck.map(c => c.name);

        // --- ROLE DEFINITIONS (Simplified for Analysis) ---
        const ROLES = {
          winConditions: [
            'Hog Rider', 'Royal Giant', 'Golem', 'Lava Hound', 'Balloon', 'Goblin Barrel',
            'Miner', 'Graveyard', 'X-Bow', 'Mortar', 'Electro Giant', 'Goblin Giant',
            'Ram Rider', 'Battle Ram', 'Wall Breakers', 'Elixir Golem', 'Skeleton Barrel', 'Three Musketeers'
          ],
          smallSpells: [
            'The Log', 'Zap', 'Giant Snowball', 'Arrows', 'Barbarian Barrel', 'Tornado', 'Royal Delivery', 'Rage'
          ],
          bigSpells: [
            'Fireball', 'Poison', 'Rocket', 'Lightning', 'Earthquake', 'Void', 'Freeze'
          ],
          airDefense: [
            'Musketeer', 'Electro Wizard', 'Wizard', 'Witch', 'Executioner', 'Hunter',
            'Baby Dragon', 'Inferno Dragon', 'Mega Minion', 'Minions', 'Minion Horde',
            'Bats', 'Spear Goblins', 'Ice Wizard', 'Princess', 'Dart Goblin', 'Magic Archer',
            'Flying Machine', 'Firecracker', 'Mother Witch', 'Skeleton Dragons', 'Phoenix',
            'Archer Queen', 'Little Prince'
          ],
          buildings: [
            'Cannon', 'Tesla', 'Inferno Tower', 'Bomb Tower', 'Tombstone', 'Goblin Cage',
            'Furnace', 'Barbarian Hut', 'Goblin Hut', 'Elixir Collector', 'Mortar', 'X-Bow'
          ],
          tankKillers: [
            'Mini P.E.K.K.A', 'P.E.K.K.A', 'Inferno Tower', 'Inferno Dragon', 'Hunter',
            'Elite Barbarians', 'Prince', 'Lumberjack', 'Barperians', 'Skeleton Army', 'Guards'
          ]
        };

        // --- CHECK 1: WIN CONDITION ---
        const hasWinCon = cardNames.some(name => ROLES.winConditions.includes(name));
        if (!hasWinCon) {
          report.health -= 30;
          report.issues.push("Missing Win Condition");
          report.suggestions.push("A Win Condition (like Hog Rider, Golem, or Miner) is essential. It's the primary way to deal damage to enemy towers. Without one, you will struggle to win matches efficiently.");
        }

        // --- CHECK 2: SPELLS ---
        const hasSmallSpell = cardNames.some(name => ROLES.smallSpells.includes(name));
        const hasBigSpell = cardNames.some(name => ROLES.bigSpells.includes(name));

        if (!hasSmallSpell) {
          report.health -= 15;
          report.issues.push("Missing Small Spell");
          report.suggestions.push("Small spells (Zap, Log, Arrows) are crucial for clearing swarm troops like Skeleton Army or Goblin Gang. They also reset Inferno Towers and finish off low-HP towers.");
        }
        if (!hasBigSpell) {
          report.health -= 10;
          report.issues.push("Missing Big Spell");
          report.suggestions.push("Big spells (Fireball, Poison, Lightning) provide high value against clustered medium-health troops (like Musketeer or Wizard) and can deal the finishing blow to an enemy tower.");
        }

        // --- CHECK 3: AIR DEFENSE ---
        const airDefenseCount = cardNames.filter(name => ROLES.airDefense.includes(name) || ROLES.buildings.includes(name)).length;
        // Note: Some buildings hit air (Tesla, Inferno), but simplifies to just checking units primarily.
        // Let's refine: Count units that hit air vs buildings.
        const antiAirUnits = cardNames.filter(name => ROLES.airDefense.includes(name)).length;

        if (antiAirUnits < 2) {
          report.health -= 20;
          report.issues.push("Weak Air Defense");
          report.suggestions.push("You have a critical vulnerability to air attacks (Lava Hound, Balloon). You need at least 2 reliable air-targeting troops (like Musketeer, Electro Wizard, or Archers). Minions and Bats are good, but they die to Zap/Arrows, so you need a unit that survives small spells.");
        }

        // --- CHECK 4: AVERAGE ELIXIR ---
        const avgElixir = deck.reduce((sum, c) => sum + (c.elixir || c.elixirCost || 0), 0) / 8;
        if (avgElixir > 4.5) {
          report.health -= 10;
          report.issues.push("Deck Too Expensive");
          report.suggestions.push("Your average elixir is very high. Try replacing a high-cost card with a cheaper cycle card.");
        } else if (avgElixir < 2.6 && !hasWinCon) {
          // If cycle is super fast but no win con, it's just spam
          report.issues.push("Cycle Too Fast?");
        }

        // --- CHECK 5: BUILDING (Soft Check) ---
        // Not strictly required for all decks (e.g. Beatdown), but good for defense
        const hasBuilding = cardNames.some(name => ROLES.buildings.includes(name));
        // We only penalize if it's not a beatdown deck (heuristic: avg elixir < 4.0 usually needs a building)
        if (!hasBuilding && avgElixir < 4.0) {
          report.health -= 5; // Minor penalty
          report.issues.push("No Defensive Building");
          report.suggestions.push("For decks this light (Cycle/Control), a defensive building (Cannon, Tesla, Bomb Tower, Inferno Tower) is absolutely CRITICAL. It pulls building-targeting units like Hog Rider, Golem, and Giant into the center 'kill zone', allowing both Princess Towers to shoot them. Without one, you will constantly take massive damage from simple pushes.");
        }

        // Final Clamp
        report.health = Math.max(0, report.health);

        return report;
      },

      /**
       * Suggests a card to remove based on analysis.
       * @param {Array} deck - Current deck
       * @returns {Object} { card: CardObject, reason: string } or null
       */
      proposeRemoval: function (deck, intendedAddRole = null) {
        if (!deck || deck.length === 0) return null;

        // 1. Identify Roles & Counts
        const winCons = deck.filter(c => getCardRole(c.name).includes('winCon'));
        const smallSpells = deck.filter(c => getCardRole(c.name).includes('spellSmall'));
        const buildings = deck.filter(c => getCardRole(c.name).includes('building'));

        // 2. Identify Synergies (Don't break pairs!)
        const synergies = window.SynergyMatrix ? window.SynergyMatrix.analyze(deck) : [];
        const synergizedCards = new Set();
        synergies.forEach(pair => { synergizedCards.add(pair[0]); synergizedCards.add(pair[1]); });

        // Rule A: Too many small spells (>=3 is bad, 2 is okay but reducible)
        if (smallSpells.length >= 3) {
          return {
            card: smallSpells.sort((a, b) => (META_QUALITY[a.name] || 50) - (META_QUALITY[b.name] || 50))[0],
            reason: "Having 3+ small spells is overkill. You need more troops for defense/offense."
          };
        }

        // Rule B: Score-based Removal with Protections
        let worstCard = null;
        let minScore = 999;

        deck.forEach(c => {
          let score = META_QUALITY[c.name] || 50;
          const role = getCardRole(c.name);

          // PROTECTIONS ðŸ›¡ï¸
          // 1. Never remove the only Win Condition
          if (role.includes('winCon') && winCons.length === 1) score += 999;

          // 2. Protect Evolutions (User likely wants them)
          if ((c.evolutionLevel || 0) > 0) score += 50;

          // 3. Protect Synergies
          if (synergizedCards.has(c.name)) score += 40;

          // 4. Protect vital roles if scarce
          if (role.includes('spellSmall') && smallSpells.length === 1) score += 20;
          if (role.includes('building') && buildings.length === 1) score += 20;

          // 5. Level Bias (Don't suggest removing maxed cards if possible)
          if (c.level >= 14) score += 10;

          // PENALTIES ðŸ”»
          // 1. Very heavy cards in a cheap deck? (Not implemented yet)

          if (score < minScore) {
            minScore = score;
            worstCard = c;
          }
        });

        if (!worstCard) return null; // Should not happen

        return {
          card: worstCard,
          reason: synergizedCards.has(worstCard.name) ?
            "This card is weak in the current meta, though it has some synergy." :
            "This card is the statistically weakest link in your deck configuration."
        };
      },

      /**
       * Suggests a complete fix: Add Card X, Remove Card Y.
       */
      proposeFix: function (deck) {
        /**
         * Calculates a single integer score (0-500) for a deck.
         */
        getDeckScore: function (deck) {
          if (!deck || deck.length !== 8) return 0;
          const stats = this.calculateStats(deck);
          return stats.offense + stats.defense + stats.versatility + stats.cycle + stats.synergy;
        },

        /**
         * Suggests a complete fix using Brute Force Optimization.
         * 1. Pick best candidate to ADD.
         * 2. Simulates swapping it with EVERY card in the deck.
         * 3. picks the swap that yields the highest Deck Score.
         */
        proposeFix: function (deck) {
          const report = this.detect(deck);
          if (report.issues.length === 0) return null; // No fix needed

          const issue = report.issues[0]; // Fix top priority issue
          let fixRole = null;
          let suggestionText = "";
          let addReason = "";

          // Heuristic mapping for WHAT to add
          if (issue.includes("Win Condition")) {
            fixRole = "winCon";
            suggestionText = "Add a Win Condition";
            addReason = "You need a dedicated tower-damager to win reliably.";
          }
          else if (issue.includes("Small Spell")) {
            fixRole = "spellSmall";
            suggestionText = "Add a Small Spell";
            addReason = "You need a cheap spell (Log/Zap/Arrows) to clear swarms.";
          }
          else if (issue.includes("Big Spell")) {
            fixRole = "spellBig";
            suggestionText = "Add a Big Spell";
            addReason = "You need a heavy spell to finish towers and crush pushes.";
          }
          else if (issue.includes("Air Defense")) {
            fixRole = "airDefense";
            suggestionText = "Add Air Defense";
            addReason = "You are vulnerable to Balloon and Lava Hound.";
          }
          else if (issue.includes("Building")) {
            fixRole = "building";
            suggestionText = "Add a Building";
            addReason = "A building helps distract tanks like Hog Rider and Golem.";
          }

          if (!fixRole) return null;

          let candidates = [];
          if (window.currentPlayerData && window.currentPlayerData.cards) {
            candidates = window.currentPlayerData.cards.filter(c => getCardRole(c.name).includes(fixRole));
          }

          // Filter candidates
          const avgElixir = deck.reduce((acc, c) => acc + (c.elixirCost || 3), 0) / 8;
          const isHeavy = avgElixir > 4.0;

          candidates.sort((a, b) => {
            let scoreA = (META_QUALITY[a.name] || 50);
            let scoreB = (META_QUALITY[b.name] || 50);
            if ((a.level || 0) > (b.level || 0)) scoreA += 5;
            if ((b.level || 0) > (a.level || 0)) scoreB += 5;
            if (isHeavy && (a.elixirCost || 3) > 4) scoreA -= 20;
            if (isHeavy && (b.elixirCost || 3) > 4) scoreB -= 20;
            return scoreB - scoreA;
          });

          // Top Candidate to ADD
          let bestAdd = candidates.length > 0 ? candidates[0] : { name: "Hog Rider", iconUrls: { medium: "https://api-assets.clashroyale.com/cards/300/UbuVrj_tAFUulOpA_53oITt7yU8S_eG8wGqgJ8s-yv.png" } };

          // BRUTE FORCE SIMULATION ðŸ¤–
          let bestSwap = null;
          let maxScore = -1;
          let baselineScore = this.getDeckScore(deck);

          // Context check for Spell Protection
          const winCons = deck.filter(c => getCardRole(c.name).includes('winCon'));
          const smallSpells = deck.filter(c => getCardRole(c.name).includes('spellSmall'));
          const bigSpells = deck.filter(c => getCardRole(c.name).includes('spellBig'));
          const totalSpells = smallSpells.length + bigSpells.length;
          const addingSpell = getCardRole(bestAdd.name).includes('spell');

          deck.forEach((cardToRemove, index) => {
            // 1. Create Test Deck
            const testDeck = [...deck];
            testDeck[index] = bestAdd; // Swap

            // 2. Score It
            let score = this.getDeckScore(testDeck);

            // 3. Apply Constraints (Penalties to score)
            const role = getCardRole(cardToRemove.name);

            // CRITICAL PROTECTION: Never remove only WinCon (unless adding one)
            if (role.includes('winCon') && winCons.length === 1 && !fixRole.includes('winCon')) {
              score -= 500;
            }

            // CRITICAL SPELL PROTECTION
            // If we are NOT adding a spell, heavily penalize removing a spell if we have <= 2
            const isRemSpell = role.includes('spell');
            if (!addingSpell && isRemSpell && totalSpells <= 2) {
              score -= 300;
            }

            if (score > maxScore) {
              maxScore = score;
              bestSwap = cardToRemove;
            }
          });

          if (!bestSwap) return null;

          // Construct Reason
          let removeReason = `Simulations show that swapping ${bestSwap.name} for ${bestAdd.name} increases your deck's overall rating to ${Math.round(maxScore)} (from ${baselineScore}).`;

          return {
            add: bestAdd,
            remove: bestSwap,
            addReason: addReason,
            removeReason: removeReason,
            reason: `${suggestionText} (${bestAdd.name}) by removing ${bestSwap.name}.`
          };
        },
        /**
         * Calculates detailed 0-100 stats for the Radar Chart.
         */
        calculateStats: function (deck) {
          const cardNames = deck.map(c => c.name);
          const roles = {
            winCon: deck.filter(c => getCardRole(c.name).includes('winCon')).length,
            air: deck.filter(c => getCardRole(c.name).includes('airDefense')).length,
            building: deck.filter(c => getCardRole(c.name).includes('building')).length,
            spell: deck.filter(c => getCardRole(c.name).includes('spellSmall') || getCardRole(c.name).includes('spellBig')).length,
            miniTank: deck.filter(c => getCardRole(c.name).includes('miniTank')).length
          };
          const avgElixir = deck.reduce((s, c) => s + (c.elixir || c.elixirCost || 0), 0) / 8;

          // 1. OFFENSE
          // Base 40 + WinCon(30) + Spells(10 each) -> Cap 100
          let off = 40 + (roles.winCon * 30) + (roles.spell * 10);

          // 2. DEFENSE
          // Base 40 + Building(20) + MiniTank(15) + Air(10)
          let def = 40 + (roles.building * 20) + (roles.miniTank * 15) + (roles.air * 10);

          // 3. CYCLE
          // 2.6 avg -> 100, 5.0 avg -> 20
          let cyc = Math.max(20, Math.min(100, 100 - (avgElixir - 2.6) * 33));

          // 4. VERSATILITY
          // Air defense is critical. Spells are critical.
          let vers = 30;
          if (roles.air >= 2) vers += 30;
          if (roles.spell >= 2) vers += 20;
          if (roles.miniTank >= 1) vers += 20;

          // 5. SYNERGY (Placeholder for now, heuristic)
          let syn = 50;
          if (roles.winCon && roles.spell) syn += 20;
          if (roles.building) syn += 10;
          if (avgElixir < 4.0) syn += 15;

          // Clamping
          const clamp = (n) => Math.max(20, Math.min(100, n));

          return {
            offense: clamp(off),
            defense: clamp(def),
            cycle: clamp(cyc),
            versatility: clamp(vers),
            synergy: clamp(syn)
          };
        },

        /**
         * Generates SVG for Radar Chart
         */
        renderRadarChart: function (stats) {
          const size = 280; // Increased from 220 to prevent clipping
          const center = size / 2;
          const radius = 70;
          const axes = ['Offense', 'Defense', 'Versatility', 'Cycle', 'Synergy'];
          const values = [stats.offense, stats.defense, stats.versatility, stats.cycle, stats.synergy];

          // Helper to get coordinates
          const getCoords = (val, i, total) => {
            const angle = (Math.PI * 2 * i) / total - Math.PI / 2;
            const r = (val / 100) * radius;
            const x = center + r * Math.cos(angle);
            const y = center + r * Math.sin(angle);
            return [x, y];
          };

          // Draw Web Background (20%, 40%... 100%)
          let web = '';
          for (let level = 1; level <= 5; level++) {
            let points = [];
            for (let i = 0; i < 5; i++) {
              const [x, y] = getCoords(level * 20, i, 5);
              points.push(`${x},${y}`);
            }
            web += `<polygon points="${points.join(' ')}" fill="none" stroke="#444" stroke-width="1" />`;
          }

          // Draw Data Polygon
          let dataPoints = [];
          for (let i = 0; i < 5; i++) {
            const [x, y] = getCoords(values[i], i, 5);
            dataPoints.push(`${x},${y}`);
          }
          const poly = `<polygon points="${dataPoints.join(' ')}" fill="rgba(231, 76, 60, 0.5)" stroke="#e74c3c" stroke-width="2" />`;

          // Draw Axes & Labels
          let lines = '';
          let labels = '';
          for (let i = 0; i < 5; i++) {
            const [x, y] = getCoords(100, i, 5);
            lines += `<line x1="${center}" y1="${center}" x2="${x}" y2="${y}" stroke="#666" stroke-width="1" />`;

            // Label Offset
            const labelAngle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
            const lx = center + (radius + 25) * Math.cos(labelAngle); // Increased offset
            const ly = center + (radius + 25) * Math.sin(labelAngle);

            // Anchor adjustment
            let anchor = 'middle';
            if (i === 1) anchor = 'start'; if (i === 4) anchor = 'end';

            labels += `<text x="${lx}" y="${ly + 4}" text-anchor="${anchor}" fill="#fff" font-weight="bold" font-size="12px" style="text-shadow:0px 1px 3px #000;">${axes[i]}</text>`;
          }

          return `
            <svg width="${size}" height="${size}" viewBox="-40 -40 ${size + 80} ${size + 80}" style="background:rgba(0,0,0,0.2); border-radius:50%; overflow:visible; margin:20px 0;">
                ${web}
                ${lines}
                ${poly}
                ${labels}
                <circle cx="${center}" cy="${center}" r="3" fill="#fff" />
            </svg>
          `;
        }
      };

      // Expose to window immediately
      window.DeckWeakness = DeckWeakness;

      // --- SYNERGY MATRIX MOODULE (Robust V2) ---
      // --- SYNERGY MATRIX MOODULE (Robust Visual V2) ---
      const SynergyMatrix = {
        PAIRS: [
          ['Tornado', 'Executioner'], ['Tornado', 'Ice Wizard'], ['Tornado', 'Magic Archer'], ['Tornado', 'Sparky'],
          ['Hog Rider', 'Ice Golem'], ['Hog Rider', 'Earthquake'], ['Hog Rider', 'Fireball'], ['Hog Rider', 'The Log'],
          ['Golem', 'Night Witch'], ['Golem', 'Baby Dragon'], ['Golem', 'Lightning'], ['Golem', 'Lumberjack'],
          ['Lava Hound', 'Balloon'], ['Lava Hound', 'Mega Minion'], ['Lava Hound', 'Inferno Dragon'], ['Lava Hound', 'Skeleton Dragons'],
          ['Miner', 'Wall Breakers'], ['Miner', 'Poison'], ['Miner', 'Bats'], ['Miner', 'Skeleton Barrel'],
          ['Graveyard', 'Poison'], ['Graveyard', 'Baby Dragon'], ['Graveyard', 'Knight'], ['Graveyard', 'Freeze'],
          ['X-Bow', 'Tesla'], ['X-Bow', 'The Log'], ['X-Bow', 'Ice Spirit'],
          ['Royal Giant', 'Fisherman'], ['Royal Giant', 'Mother Witch'], ['Royal Giant', 'Lightning'],
          ['Goblin Barrel', 'Princess'], ['Goblin Barrel', 'Goblin Gang'], ['Goblin Barrel', 'Rocket'],
          ['P.E.K.K.A', 'Battle Ram'], ['P.E.K.K.A', 'Electro Wizard'], ['P.E.K.K.A', 'Bandit'],
          ['Giant', 'Sparky'], ['Giant', 'Prince'], ['Giant', 'Witch'],
          ['Balloon', 'Lumberjack'], ['Balloon', 'Freeze'],
          ['Electro Giant', 'Tornado'], ['Electro Giant', 'Lightning'],
          ['Elixir Golem', 'Battle Healer'], ['Elixir Golem', 'Electro Dragon'],
          ['Goblin Drill', 'Wall Breakers'], ['Goblin Drill', 'Bomber']
        ],

        analyze: function (deck) {
          const names = new Set(deck.map(c => c.name));
          const found = [];
          this.PAIRS.forEach(pair => {
            if (names.has(pair[0]) && names.has(pair[1])) {
              found.push(pair);
            }
          });
          return found;
        },

        render: function (deck) {
          // Safe access helper
          const getImg = (c) => c.iconUrls?.medium || c.iconUrls || c.iconUrl || '';

          const synergies = this.analyze(deck);

          // Remove existing modal if present
          const existing = document.getElementById('synergyModal');
          if (existing) existing.remove();

          // Setup Nodes
          const size = 320;
          const center = size / 2;
          const radius = 100;

          let cardNodes = deck.map((c, i) => {
            const angle = (Math.PI * 2 * i) / 8 - Math.PI / 2;
            return {
              name: c.name,
              x: center + radius * Math.cos(angle),
              y: center + radius * Math.sin(angle),
              img: getImg(c),
              angle: angle
            };
          });

          // Setup Links
          const nodeMap = {};
          cardNodes.forEach(n => nodeMap[n.name] = n);

          const validLinks = [];
          synergies.forEach(pair => {
            if (nodeMap[pair[0]] && nodeMap[pair[1]]) {
              validLinks.push({
                source: nodeMap[pair[0]],
                target: nodeMap[pair[1]]
              });
            }
          });

          // Build SVG HTML
          let svgLines = validLinks.map(link =>
            `<line x1="${link.source.x}" y1="${link.source.y}" x2="${link.target.x}" y2="${link.target.y}" stroke="#00d2ff" stroke-width="2" opacity="0.8" />`
          ).join('');

          let svgNodes = cardNodes.map(node => `
            <g transform="translate(${node.x},${node.y})" class="synergy-node">
                <circle r="22" fill="#111" stroke="${validLinks.some(l => l.source === node || l.target === node) ? '#00d2ff' : '#444'}" stroke-width="2"></circle>
                <image href="${node.img}" x="-20" y="-20" height="40" width="40" clip-path="circle(20px)" />
                <title>${node.name}</title>
            </g>
        `).join('');

          const html = `
            <div id="synergyModal" style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:9999; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(4px);">
                <div style="position:relative; width:360px; height:480px; background:linear-gradient(145deg, #1a1a1a, #2a2a2a); border-radius:20px; box-shadow:0 0 40px rgba(0,210,255,0.2); border:1px solid #333; display:flex; flex-direction:column; align-items:center;">
                    
                    <h2 style="color:#00d2ff; font-family:'Supercell', sans-serif; margin-top:20px; text-shadow:0 0 10px rgba(0,210,255,0.5);">SYNERGY MATRIX</h2>
                    
                    <div style="position:relative; width:${size}px; height:${size}px; margin-top:10px;">
                        <svg width="${size}" height="${size}" style="overflow:visible;">
                            ${svgLines}
                            ${svgNodes}
                        </svg>
                    </div>

                    <div style="margin-top:auto; margin-bottom:20px; width:100%; text-align:center;">
                        <div style="color:#aaa; font-size:12px; margin-bottom:10px;">
                            ${synergies.length} Synergy Pair(s) Detected
                        </div>
                        <button onclick="document.getElementById('synergyModal').remove()" 
                            style="background:#333; color:#fff; border:1px solid #555; padding:8px 24px; border-radius:20px; cursor:pointer; font-weight:bold; transition:all 0.2s;">
                            CLOSE
                        </button>
                    </div>

                    <div style="position:absolute; top:10px; right:15px; cursor:pointer; color:#666; font-size:20px;" onclick="document.getElementById('synergyModal').remove()">âœ•</div>
                </div>
            </div>
        `;

          document.body.insertAdjacentHTML('beforeend', html);
        }
      };
      window.SynergyMatrix = SynergyMatrix;

      // --- DECK STATS RADAR (New Feature) ---
      const DeckRadar = {
        calculate: function (deck) {
          // Tuned Scoring (40-100 scale for viable decks)
          let offense = 40, defense = 40, cycle = 50, air = 40, synergy = 40;
          let reasons = { offense: [], defense: [], cycle: [], air: [], synergy: [] };

          let buildingCount = 0;
          let spellCount = 0;
          let totalElixir = 0;
          let winCons = [];
          let airCounters = [];

          // Fallback list in case global fails or for extra coverage
          const KNOWN_WCS = ['Hog Rider', 'Royal Giant', 'Golem', 'Giant', 'Balloon', 'Miner', 'Goblin Barrel', 'Wall Breakers', 'Graveyard', 'Lava Hound', 'Elixir Golem', 'Electro Giant', 'Goblin Giant', 'Ram Rider', 'Battle Ram', 'Royal Hogs', 'Mortar', 'X-Bow', 'Skeleton Barrel', 'Three Musketeers', 'Sparky', 'Mega Knight', 'P.E.K.K.A', 'Prince'];

          deck.forEach(c => {
            totalElixir += c.elixirCost || 0;

            // Offense Logic
            let isWinCon = false;
            // Check Global Guide OR Fallback List
            if ((window.WIN_CONDITION_GUIDES && window.WIN_CONDITION_GUIDES[c.name]) || KNOWN_WCS.includes(c.name)) {
              offense += 20;
              winCons.push(c.name);
              isWinCon = true;
            }

            if (!isWinCon && c.elixirCost >= 4 && (c.type === 'Troop')) {
              offense += 5; // Heavy troops add some offensive pressure
            }

            if (['Champion', 'Legendary'].includes(c.rarity)) offense += 5;

            if (['Rare', 'Epic', 'Legendary', 'Champion'].includes(c.rarity)) offense += 2;

            // Defense Logic
            // Buildings
            if (c.type === 'Building' || c.name.includes('Tower') || c.name.includes('Tesla') || c.name.includes('Cannon') || c.name.includes('Cage') || c.name.includes('Tombstone')) {
              defense += 20;
              buildingCount++;
              reasons.defense.push(c.name);
            }
            // Robust Defenders
            const strongDefenders = ['Knight', 'Valkyrie', 'Ice Golem', 'Mini P.E.K.K.A', 'P.E.K.K.A', 'Mega Knight', 'Prince', 'Dark Prince', 'Hunter', 'Fisherman', 'Bowler', 'Executioner', 'Golden Knight', 'Skeleton King', 'Mighty Miner', 'Barbarians', 'Elite Barbarians', 'Royal Recruits'];
            if (strongDefenders.includes(c.name)) {
              defense += 15;
              if (!reasons.defense.includes(c.name)) reasons.defense.push(c.name);
            }
            // Swarm Defense
            if (['Guards', 'Goblin Gang', 'Skeleton Army', 'Rascals', 'Bats'].includes(c.name)) {
              defense += 10;
            }

            // Air Defense
            const antiAir = ['Musketeer', 'Wizard', 'Archer', 'Minion', 'Dragon', 'Witch', 'Hunter', 'Firecracker', 'Tesla', 'Inferno', 'Executioner', 'Dart Goblin', 'Phoenix', 'Mother Witch', 'Flying Machine', 'Spear Goblins', 'Bats', 'Magic Archer', 'Zappies'];
            if (antiAir.some(k => c.name.includes(k))) {
              air += 15;
              airCounters.push(c.name);
            }

            if (c.type === 'Spell') {
              spellCount++;
              if (c.damage > 500) { offense += 10; reasons.offense.push("Big Spell"); }
            }
          });

          const avgElixir = totalElixir / 8;

          // --- Logic Refining ---

          // Offense logic
          if (winCons.length > 0) {
            reasons.offense.unshift(`Driven by ${winCons.slice(0, 2).join(', ')}`);
          } else {
            offense -= 20;
            reasons.offense.push("Lacks a primary Win Condition");
          }

          // Defense
          if (buildingCount === 0) {
            // Check for high DPS tank killers as substitute
            const tankKillers = deck.filter(c => ['P.E.K.K.A', 'Mini P.E.K.K.A', 'Hunter', 'Prince', 'Elite Barbarians', 'Inferno Dragon'].includes(c.name));
            if (tankKillers.length > 0) {
              reasons.defense.push(`Defense relies on ${tankKillers[0].name}`);
              defense -= 5; // Mild penalty
            } else {
              reasons.defense.push("No Building/Tank Killer");
              defense -= 20; // Harsh penalty
            }
          }

          // Air logic
          if (airCounters.length >= 2) {
            reasons.air.push(`Anti-Air: ${airCounters.slice(0, 2).join(', ')}`);
          } else if (airCounters.length === 1) {
            reasons.air.push(`Weak Air: ${airCounters[0]}`);
            air -= 10;
          } else {
            reasons.air.push("Vulnerable to Air");
            air -= 30;
          }

          // Cycle Score
          cycle = Math.max(0, Math.min(100, (5.0 - avgElixir) * 30 + 10)); // Curve it up
          reasons.cycle.push(`${avgElixir.toFixed(1)} Avg Elixir`);
          if (avgElixir <= 3.3) reasons.cycle.push("Fast Cycle");
          else if (avgElixir >= 4.0) reasons.cycle.push("Heavy Beatdown");
          else reasons.cycle.push("Balanced Weight");

          // Synergy Score
          const syns = SynergyMatrix.analyze(deck);
          synergy = Math.min(100, 40 + syns.length * 15); // Start at 40
          if (syns.length > 0) {
            reasons.synergy.push(`${syns.length} Known Pairs`);
            reasons.synergy.push(`Top: ${syns[0]}`);
          } else {
            reasons.synergy.push("Loose Synergy");
            synergy = 30;
          }

          // Clamp all
          const clamp = (n) => Math.max(10, Math.min(100, n));

          return {
            scores: {
              offense: clamp(offense),
              defense: clamp(defense),
              cycle: clamp(cycle),
              air: clamp(air),
              synergy: clamp(synergy)
            },
            reasons: reasons
          };
        },

        render: function (deck) {
          const analysis = this.calculate(deck);
          const { scores, reasons } = analysis;
          const data = [scores.offense, scores.defense, scores.cycle, scores.air, scores.synergy];
          const labels = ["OFF", "DEF", "CYC", "AIR", "SYN"];

          // SVG Config
          const size = 300;
          const center = size / 2;
          const radius = 90;
          const sides = 5;

          // Calculate Points
          const getPoint = (value, i) => {
            const angle = (Math.PI * 2 * i) / sides - Math.PI / 2;
            const r = (value / 100) * radius;
            return {
              x: center + r * Math.cos(angle),
              y: center + r * Math.sin(angle)
            };
          };

          // Background Webs
          let webs = '';
          [20, 40, 60, 80, 100].forEach(level => {
            let points = [];
            for (let i = 0; i < sides; i++) {
              const p = getPoint(level, i);
              points.push(`${p.x},${p.y}`);
            }
            webs += `<polygon points="${points.join(' ')}" fill="none" stroke="#444" stroke-width="1" />`;
          });

          // Data Polygon
          let dataPoints = [];
          data.forEach((v, i) => {
            const p = getPoint(v, i);
            dataPoints.push(`${p.x},${p.y}`);
          });
          const polyStr = dataPoints.join(' ');

          // Labels with Scores
          let labelHtml = labels.map((lbl, i) => {
            const angle = (Math.PI * 2 * i) / sides - Math.PI / 2;
            const r = radius + 30; // Push out further
            const x = center + r * Math.cos(angle);
            const y = center + r * Math.sin(angle);
            const val = data[i];

            // Color scale based on value
            const color = val > 80 ? '#00ff00' : val > 50 ? '#00d2ff' : '#ffaa00';

            return `
                <text x="${x}" y="${y - 8}" fill="#fff" font-size="12" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${lbl}</text>
                <text x="${x}" y="${y + 8}" fill="${color}" font-size="14" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${Math.round(val)}</text>
            `;
          }).join('');

          const html = `
            <div id="radarModal" style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:9999; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(5px);">
                <div style="position:relative; width:400px; max-height:90vh; overflow-y:auto; background:linear-gradient(145deg, #181818, #222); border-radius:16px; box-shadow:0 0 50px rgba(0,210,255,0.15); border:1px solid #333; display:flex; flex-direction:column; align-items:center;">
                    
                    <h2 style="color:#fff; font-family:'Supercell', sans-serif; margin:20px 0 10px 0; letter-spacing:1px;">DECK RADAR <span style="font-size:0.6em; color:#00d2ff;">v2</span></h2>
                    
                    <div style="position:relative; width:${size}px; height:${size}px;">
                        <svg width="${size}" height="${size}" style="overflow:visible;">
                            ${webs}
                            <polygon points="${polyStr}" fill="rgba(0, 210, 255, 0.3)" stroke="#00d2ff" stroke-width="2" />
                            ${dataPoints.map(p => `<circle cx="${p.split(',')[0]}" cy="${p.split(',')[1]}" r="4" fill="#fff" />`).join('')}
                            ${labelHtml}
                        </svg>
                    </div>

                    <div style="width:90%; background:rgba(0,0,0,0.3); border-radius:12px; padding:15px; margin-bottom:20px; font-size:13px; color:#ddd;">
                        ${labels.map((lbl, i) => {
            const key = Object.keys(reasons)[i];
            const text = reasons[key].join(', ') || 'Standard';
            const val = data[i];
            const color = val > 80 ? '#4eff4e' : val > 50 ? '#00d2ff' : '#ffaa00';
            return `
                                <div style="display:flex; justify-content:space-between; margin-bottom:8px; border-bottom:1px solid #333; padding-bottom:4px;">
                                    <span style="font-weight:bold; color:${color}; width:40px;">${lbl}</span>
                                    <span style="flex:1; text-align:right; font-style:italic; color:#bbb;">${text}</span>
                                </div>
                            `;
          }).join('')}
                    </div>

                    <div style="margin-bottom:20px;">
                        <button onclick="document.getElementById('radarModal').remove()" 
                            style="background:#333; color:#fff; border:1px solid #555; padding:10px 30px; border-radius:20px; cursor:pointer; font-weight:bold; transition:all 0.2s; font-family:inherit;">
                            CLOSE REPORT
                        </button>
                    </div>

                    <div style="position:absolute; top:15px; right:20px; cursor:pointer; color:#666; font-size:24px;" onclick="document.getElementById('radarModal').remove()">&times;</div>
                </div>
            </div>
        `;

          const old = document.getElementById('radarModal');
          if (old) old.remove();
          document.body.insertAdjacentHTML('beforeend', html);
        }
      };
      window.DeckRadar = DeckRadar;
  </script>

  <script type="module">
      import { MatchupAnalyzer } from './matchup_analyzer.js';
      // DeckWeakness is now inlined above to fix local file loading

      window.MatchupAnalyzer = MatchupAnalyzer;

      // Weakness Button Logic - DISABLED
      const wBtn = document.getElementById('weaknessBtn');
      if(wBtn) wBtn.onclick = () => {
        console.log("Weakness Button Clicked - Disabled");
      };
      /*
      document.getElementById('weaknessBtn').onclick = () => {
        if (!window.currentAppDeck || window.currentAppDeck.length === 0) {
          alert("Scan a deck first!");
          return;
        }
  
        const report = DeckWeakness.detect(window.currentAppDeck);
        const scoreEl = document.getElementById('weaknessScore');
        const bodyEl = document.getElementById('weaknessBody');
  
        // Color Code Score
        let color = '#e74c3c';
        if (report.health > 80) color = '#2ecc71';
        else if (report.health > 50) color = '#f1c40f';
  
        scoreEl.innerText = `${report.health}% Health`;
        scoreEl.style.color = color;
  
        // Build HTML
        let html = '';
        if (report.issues.length === 0) {
          html += `<div style="padding:10px; background:rgba(46, 204, 113, 0.2); border-radius:5px;">âœ… Your deck is well balanced!</div>`;
        } else {
          html += `<h4 style="color:#e74c3c; margin-bottom:5px;">âš ï¸ Critical Issues:</h4><ul>`;
          report.issues.forEach(i => html += `<li>${i}</li>`);
          html += `</ul>`;
        }
  
        if (report.suggestions.length > 0) {
          html += `<h4 style="color:#f1c40f; margin-bottom:5px;">ðŸ’¡ Suggestions:</h4><ul>`;
          report.suggestions.forEach(s => html += `<li>${s}</li>`);
          html += `</ul>`;
        }
  
        // INJECT SUGGEST DROP AREA
        html += `<div id="suggestDropArea" style="margin-top:20px; text-align:center; padding-top:15px; border-top:1px solid #444; display:flex; gap:10px; justify-content:center;"></div>`;
  
        bodyEl.innerHTML = html;
  
        // Add Buttons
        const area = document.getElementById('suggestDropArea');
  
        // 1. Suggest Fix Button (NEW)
        const btnFix = document.createElement('button');
        btnFix.innerText = "ðŸ”§ Suggest Fix";
        btnFix.className = "action-btn";
        btnFix.style.background = "linear-gradient(135deg, #2ecc71, #27ae60)";
        btnFix.style.fontSize = "14px";
        btnFix.style.padding = "8px 16px";
        btnFix.onclick = () => {
          try {
            const fix = DeckWeakness.proposeFix(window.currentAppDeck);
            if (fix) {
              area.innerHTML = `
                      <div style="background:rgba(39, 174, 96, 0.2); padding:15px; border-radius:8px; margin-top:10px; border:1px solid #27ae60; width:100%;">
                          <div style="font-weight:bold; color:#2ecc71; margin-bottom:10px; font-size:1.1em;">Recommended Fix:</div>
                          <div style="display:flex; align-items:center; justify-content:center; gap:15px; margin-bottom:10px;">
                              <div style="text-align:center;">
                                  <div style="color:#e74c3c; font-size:12px; font-weight:bold;">REMOVE</div>
                                  <img src="${fix.remove.iconUrls?.medium || fix.remove.iconUrls || fix.remove.iconUrl}" style="width:50px;">
                                  <div style="font-size:12px;">${fix.remove.name}</div>
                              </div>
                              <div style="font-size:24px; color:#aaa;">âž</div>
                              <div style="text-align:center;">
                                  <div style="color:#2ecc71; font-size:12px; font-weight:bold;">ADD</div>
                                  <img src="${fix.add.iconUrls?.medium || fix.add.iconUrls || fix.add.iconUrl}" style="width:50px;">
                                  <div style="font-size:12px;">${fix.add.name}</div>
                              </div>
                          </div>
                          <div style="font-size:0.9em; color:#ddd; margin-bottom:15px; font-style:italic;">"${fix.reason}"</div>
                          <button id="applyFixBtn" class="action-btn" style="background:#27ae60; width:100%;">âœ… Apply Fix</button>
                          <button onclick="document.getElementById('weaknessBtn').click()" style="background:transparent; border:none; color:#aaa; text-decoration:underline; margin-top:10px; cursor:pointer;">Cancel</button>
                      </div>
                  `;
  
              document.getElementById('applyFixBtn').onclick = () => {
                // Update Deck
                const newDeck = window.currentAppDeck.filter(c => c.name !== fix.remove.name);
                newDeck.push(fix.add);
  
                // Update Globals
                window.currentAppDeck = newDeck;
                window.builderDeck = newDeck; // Sync builder too
                if (window.currentPlayerData) window.currentPlayerData.currentDeck = newDeck;
  
                // Render
                renderDeck(window.currentPlayerData || { currentDeck: newDeck }); // Hacky but works for UI update
  
                // Close Modal
                document.getElementById('weaknessModal').style.display = 'none';
                alert(`Swapped ${fix.remove.name} with ${fix.add.name}!`);
              };
  
            } else {
              area.innerHTML = `<div style="color:#aaa; margin-top:10px;">No clear fix found. Try manual adjustments.</div>`;
            }
          } catch (e) {
            console.error("Suggest Fix Error:", e);
            area.innerHTML = `<div style="color:#e74c3c; margin-top:10px;">Error finding fix: ${e.message}</div>`;
          }
        };
  
        // 2. Suggest Drop Button (Legacy)
        const btnDrop = document.createElement('button');
        btnDrop.innerText = "ðŸ“‰ Suggest DropOnly";
        btnDrop.className = "action-btn";
        btnDrop.style.background = "#c0392b";
        btnDrop.style.fontSize = "14px";
        btnDrop.style.padding = "8px 16px";
        btnDrop.onclick = () => {
          const suggestion = DeckWeakness.proposeRemoval(window.currentAppDeck);
          if (suggestion && suggestion.card) {
            area.innerHTML = `
                      <div style="background:rgba(192, 57, 43, 0.2); padding:10px; border-radius:8px; margin-top:10px; border:1px solid #c0392b; width:100%;">
                          <div style="font-weight:bold; color:#e74c3c; margin-bottom:5px;">Recommended Cut:</div>
                          <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
                              <img src="${suggestion.card.iconUrls?.medium || suggestion.card.iconUrls || suggestion.card.iconUrl}" style="width:40px;">
                              <span style="font-size:1.2em; font-weight:bold;">${suggestion.card.name}</span>
                          </div>
                          <div style="font-size:0.9em; color:#ddd; margin-top:5px; font-style:italic;">"${suggestion.reason}"</div>
                          <button onclick="document.getElementById('weaknessBtn').click()" style="background:transparent; border:none; color:#aaa; text-decoration:underline; margin-top:10px; cursor:pointer;">Reset</button>
                      </div>
                   `;
          } else {
            area.innerHTML = `<div style="color:#aaa; margin-top:10px;">No specific remove suggestions. Try standard substitutions.</div>`;
          }
        };
  
        area.appendChild(btnFix);
        area.appendChild(btnDrop);
  
        // document.getElementById('weaknessModal').style.display = 'flex';
        console.log('Weakness Modal suppressed by user request.');
      };
      */
  </script>
  <script type="module">
      import { WIN_CONDITION_GUIDES } from './win_conditions.js?v=6';

    (function () {
        // Setup Win Condition Modal Logic (Global Scope hack for HTML onclicks)
        const modal = document.getElementById('winConditionModal');
        const list = document.getElementById('guideList');
        const detail = document.getElementById('guideDetail');
        const grid = document.getElementById('winConditionGrid');
        const winConBtn = document.getElementById('winConGuideBtn');
        const backBtn = document.getElementById('backToGuideList');

        if (winConBtn) winConBtn.onclick = () => {
          renderWinConditionList();
          modal.style.display = 'flex';
        };

        if (backBtn) backBtn.onclick = () => {
          detail.style.display = 'none';
          list.style.display = 'block';
        };

        // Expose to window for the Create Card Elements
        window.showGuide = (name) => {
          const guide = WIN_CONDITION_GUIDES[name];
          if (!guide) return;

          list.style.display = 'none';
          detail.style.display = 'block';

          const title = document.getElementById('guideTitle');
          const body = document.getElementById('guideBody');

          title.innerHTML = `${name} <span style="font-size:14px; color:#aaa">(${guide.role})</span>`;

          // Strategy HTML
          let strategyHTML = guide.strategy.map(tip => `
            <li style="margin-bottom:10px; color:#ddd">${tip.replace(/\*\*(.*?)\*\*/g, '<strong style="color:var(--gold)">$1</strong>')}</li >
      `).join('');

          // Build the ROLE GRID
          const rolesContainer = document.createElement('div');
          rolesContainer.className = 'role-grid-container';

          guide.composition.forEach((comp, index) => {
            const card = document.createElement('div');
            card.className = 'role-card';
            card.textContent = comp.abbr || '??';
            card.style.backgroundColor = comp.color || '#555';
            card.title = comp.role; // Tooltip

            // Click handler
            card.onclick = () => {
              // Highlight
              document.querySelectorAll('.role-card').forEach(c => c.classList.remove('selected'));
              card.classList.add('selected');

              // Show Detail
              const detailArea = document.getElementById('roleDetailArea');
              detailArea.style.display = 'block';
              detailArea.innerHTML = `
      < strong style = "color:${comp.color}; font-size:1.2em; text-shadow:1px 1px 0 #000" > ${comp.role}</strong >
                <div style="font-size:0.95em; margin-top:8px; color:#eee">${comp.reason}</div>
                <div style="margin-top:10px; font-size:0.9em; color:#ccc">
                    <span style="color:#aaa">Top Picks:</span> <span style="color:#fff">${comp.examples.join(', ')}</span>
                </div>
    `;
            };

            // Auto-select first one? No, let user explore.
            rolesContainer.appendChild(card);
          });

          body.innerHTML = `
      < p style = "font-size:1.1em; color:#fff; margin-bottom:20px; font-style:italic;" > "${guide.description}"</p >
            
            <h3 style="color:var(--gold); border-bottom:1px solid #444; padding-bottom:5px;">Required Deck Components</h3>
            <p style="font-size:12px; color:#aaa; margin-bottom:15px;">Click the cards below to see details.</p>
            
            <!-- Insert Grid -->
            <div id="rolesWrapper"></div>
            
            <!--Insert Detail Area-- >
            <div id="roleDetailArea"></div>

            <h3 style="color:var(--gold); border-bottom:1px solid #444; padding-bottom:5px; margin-top:30px;">How to Play</h3>
            <ul style="padding-left:20px; text-align:left;">${strategyHTML}</ul>
    `;

          document.getElementById('rolesWrapper').appendChild(rolesContainer);
        }

        function renderWinConditionList() {
          grid.innerHTML = '';
          Object.keys(WIN_CONDITION_GUIDES).forEach(name => {
            const guide = WIN_CONDITION_GUIDES[name];

            const div = document.createElement('div');
            div.className = 'win-con-card';
            div.onclick = () => window.showGuide(name);

            // Fallback if image fails (though URL should work)
            // Use a colored gradient background if no image
            div.innerHTML = `
      < img src = "${guide.imgUrl}" alt = "${name}" onerror = "this.style.display='none';this.parentElement.style.background='#333'" >
        <div class="win-con-label">${name}</div>
             `;
            grid.appendChild(div);
          });
        }

      })();
  </script>
  <script>
    (function () {
      // GLOBAL ERROR TRAP
      window.onerror = function (msg, url, line) {
        alert("Global Error: " + msg + "\nLine: " + line);
        return false;
      };

      const BASE_URL = ''; // Relative path for remote access
      // Toggle placeholder layout to match mockup (green boxes)
      const PLACEHOLDER_LAYOUT = false; // set true to show green-box mockup
      const TIMEOUT_MS = 15000; // Increased for slower connections

      // FETCH LIVE META
      async function fetchLiveMeta() {
        try {
          const res = await fetch('/api/meta-snapshot');
          if (res.ok) {
            const decks = await res.json();
            if (window.addLiveDecks) {
              window.addLiveDecks(decks);
              // Notify User
              const aiStatus = document.getElementById('aiStatus');
              if (aiStatus) {
                aiStatus.textContent = `âœ¨ AI Updated: ${decks.length} new top decks loaded via Live Scraper.`;
                aiStatus.style.color = '#2ecc71';
              }
            }
          }
        } catch (e) {
          console.warn('Live meta fetch failed', e);
        }
      }
      fetchLiveMeta();

      const input = document.getElementById('tagInput');
      const btn = document.getElementById('scanBtn');
      const demoBtn = document.getElementById('demoBtn');
      const output = document.getElementById('output');


      // Pre-fill from LocalStorage
      const cachedTag = localStorage.getItem('cachedPlayerTag');
      if (cachedTag && input) {
        input.value = cachedTag;
      }

      // --- META QUALITY TIER LIST (Using Global Scope Version) ---
      // Removed local duplicate to ensure consistency with DeckWeakness

      const DEMO_DECK = [
        { name: 'Knight', level: 13, elixirCost: 3, iconUrls: { medium: 'https://api-assets.clashroyale.com/cards/300/jAj1Q5rclXxU9kVImGqSJxa4wEMfEhvwKQnmpY31TvU.png' } },
        { name: 'Archers', level: 13, elixirCost: 3, iconUrls: { medium: 'https://api-assets.clashroyale.com/cards/300/W4Hmp8MTSdXJOYzwv3oCxSsE2s.png' } },
        { name: 'Giant', level: 13, elixirCost: 5, iconUrls: { medium: 'https://api-assets.clashroyale.com/cards/300/Axr4ox5_b7edjd9sDiSRitiDqgJKZgDq8kZuVcdwGZ8.png' } },
        { name: 'Musketeer', level: 13, elixirCost: 4, iconUrls: { medium: 'https://api-assets.clashroyale.com/cards/300/Tex184ac3uJLppEA4qfprZGtn1v7Tx72gFSfF0rAX58.png' } },
        { name: 'Bomber', level: 13, elixirCost: 2, iconUrls: { medium: 'https://api-assets.clashroyale.com/cards/300/12n1CesxKIuo79kpf8zXPjSima5Iq7GqqQzCsTPboho.png' } },
        { name: 'Fireball', level: 13, elixirCost: 4, iconUrls: { medium: 'https://api-assets.clashroyale.com/cards/300/lUMIwH8wZSVuF0wIFiXa6qC8q8q0gV0ycfc7L8i.png' } },
        { name: 'Skeletons', level: 13, elixirCost: 1, iconUrls: { medium: 'https://api-assets.clashroyale.com/cards/300/oO7iKM9587-K7i8Z.png' } },
        { name: 'Mini P.E.K.K.A', level: 13, elixirCost: 4, iconUrls: { medium: 'https://api-assets.clashroyale.com/cards/300/F4442sP_Pclpeq.png' } }
      ];

      const DEMO_PLAYER = {
        name: 'DemoPlayer', tag: '#DEMO123', expLevel: 13, trophies: 4231, bestTrophies: 4500,
        wins: 1234, losses: 567, clan: { name: 'Demo Clan', tag: '#CLAN1' },
        supportCards: [{ name: 'Tower Princess', level: 13, iconUrls: { medium: 'https://api-assets.clashroyale.com/cards/300/NlU_6FQppMcgsjsxND4X5g2I14lDw4a3oX_197qj42s.png' } }]
      };

      // GLOBAL DECK TRACKER
      window.currentAppDeck = [];
      // WEAKNESS CHECK BUTTON HANDLER
      const weaknessBtnSetup = document.getElementById('weaknessReportBtn');
      if (weaknessBtnSetup) {
        weaknessBtnSetup.onclick = () => {
          window.dispatchEvent(new Event('SHOW_WEAKNESS_REPORT'));
        };
      }

      // SYNERGY BTN SETUP (Inline for reliability)
      // SYNERGY BTN SETUP (Global function for reliability)
      // openSynergyMatrix wrapper removed

      // SYNC SYNERGY BUTTON VISIBILITY
      const weaknessBtn = document.getElementById('weaknessReportBtn');
      const synerBtn = document.getElementById('synergyBtn');
      if (weaknessBtn && synerBtn) {
        const observer = new MutationObserver(() => {
          // DISABLED: Do not hide synergy button automatically
          // console.log("Observer disabled for debugging");
        });
        observer.observe(weaknessBtn, { attributes: true, attributeFilter: ['style'] });

        // Initial check
        if (weaknessBtn.style.display !== 'none') synerBtn.style.display = 'inline-block';
      }


      // LISTENER FOR WEAKNESS CHECK
      window.addEventListener('SHOW_WEAKNESS_REPORT', () => {
        if (!window.DeckWeakness) { console.error('DeckWeakness module not loaded'); return; }

        let deckToAnalyze = window.currentAppDeck;
        // If empty, maybe try demo deck?
        if (!deckToAnalyze || deckToAnalyze.length === 0) {
          deckToAnalyze = DEMO_DECK; // Fallback for safety/testing
        }

        const result = window.DeckWeakness.detect(deckToAnalyze);
        // NEW: Calculate Stats for Holographic Radar
        const stats = window.DeckWeakness.calculateStats ? window.DeckWeakness.calculateStats(deckToAnalyze) : { offense: 50, defense: 50, cycle: 50, versatility: 50, synergy: 50 };
        const radarSVG = window.DeckWeakness.renderRadarChart ? window.DeckWeakness.renderRadarChart(stats) : '';

        const modal = document.getElementById('weaknessModal');
        const scoreEl = document.getElementById('weaknessScore');
        const bodyEl = document.getElementById('weaknessBody');

        let color = '#2ecc71';
        if (result.health < 60) color = '#e74c3c';
        else if (result.health < 85) color = '#f1c40f';

        // 1. Render Score
        scoreEl.innerHTML = `
      <div style="text-align:center;">
            <div style="font-size:16px; color:#aaa; margin-bottom:10px; letter-spacing:1px; text-transform:uppercase;">Overall Health</div>
            <div style="color:${color}; font-size:64px; font-weight:900; line-height:1; margin-bottom:20px; text-shadow:0 0 20px ${color}40;">${result.health}%</div>
            ${radarSVG}
        </div>
      `;
        // scoreEl.style.color = color; // Handled inline now

        // 2. Render Weakness Body HTML
        // ... keep existing body logic, maybe simplify ...
        let html = '';
        if (result.issues.length === 0) {
          html = `<div style="text-align:center; padding:20px;">
                    <h3 style="color:#2ecc71; font-size:24px;">âœ… Operational</h3>
                    <p>All critical systems are functioning within normal parameters.</p>
                </div>`;
        } else {
          html = `<h3 style="color:#e74c3c; border-bottom:1px solid #444; padding-bottom:5px;">âš ï¸ System Weaknesses Detected</h3>`;

          // PRE-CALCULATE FIX
          let fixHTML = '';
          if (window.DeckWeakness.proposeFix) {
            const fix = window.DeckWeakness.proposeFix(deckToAnalyze);
            if (fix && fix.bestAdd && fix.removal) {
              fixHTML = `
                 <div style="margin-top:12px; margin-bottom:20px; background:rgba(46, 204, 113, 0.1); border:1px solid rgba(46, 204, 113, 0.3); border-radius:12px; padding:15px; margin-left:10px;">
                     <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px; border-bottom:1px solid rgba(46, 204, 113, 0.2); padding-bottom:8px;">
                         <div style="font-size:20px;">ðŸ’¡</div>
                         <div style="font-weight:bold; color:#2ecc71; font-size:15px; letter-spacing:0.5px; text-transform:uppercase;">Recommended Action</div>
                     </div>
                     <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:12px;">
                         <!-- OUT -->
                         <div style="text-align:center; flex:1; position:relative;">
                             <div style="font-size:10px; color:#e74c3c; font-weight:bold; margin-bottom:4px; letter-spacing:1px; background:rgba(231, 76, 60, 0.2); display:inline-block; padding:2px 6px; border-radius:4px;">OUT</div>
                             <div style="position:relative; width:50px; height:60px; margin:0 auto;">
                                 <img src="${fix.removal.card.iconUrls.medium}" style="width:100%; height:100%; object-fit:contain; filter:grayscale(100%) opacity(0.7);">
                                 <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#e74c3c; font-size:30px; font-weight:bold;">âœ•</div>
                             </div>
                             <div style="font-size:10px; margin-top:2px; color:#aaa; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${fix.removal.card.name}</div>
                         </div>
                         <!-- ARROW -->
                         <div style="color:#555; font-size:20px;">âž”</div>
                          <!-- IN -->
                         <div style="text-align:center; flex:1;">
                             <div style="font-size:10px; color:#2ecc71; font-weight:bold; margin-bottom:4px; letter-spacing:1px; background:rgba(46, 204, 113, 0.2); display:inline-block; padding:2px 6px; border-radius:4px;">IN</div>
                             <img src="${fix.bestAdd.iconUrls.medium}" style="width:55px; height:66px; object-fit:contain; filter:drop-shadow(0 0 5px rgba(46,204,113,0.4)); transform:scale(1.05);">
                             <div style="font-size:11px; margin-top:2px; color:#fff; font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${fix.bestAdd.name}</div>
                         </div>
                     </div>
                     <div style="font-size:12px; color:#ddd; line-height:1.5;">
                         <strong style="color:#2ecc71;">Why:</strong> ${fix.addReason}
                         <div style="margin-top:4px; color:#888; font-size:11px; font-style:italic;">Removing ${fix.removal.card.name}: ${fix.removeReason}</div>
                     </div>
                 </div>`;
            }
          }

          result.issues.forEach((issue, idx) => {
            html += `<div style="margin-bottom:12px; border-left:3px solid #e74c3c; padding-left:10px;">
                      <div style="font-size:16px; font-weight:bold; color:#e74c3c;">${issue}</div>
                      <div style="font-size:12px; color:#aaa; margin-top:2px;">${result.suggestions[idx]}</div>
                  </div>`;

            // INJECT FIX AFTER THE FIRST ISSUE (Primary Weakness)
            if (idx === 0 && fixHTML) {
              html += fixHTML;
            }
          });
        }
        bodyEl.innerHTML = html;

        // 3. Render Footer Buttons (Simplified - No more "Weakness" modal inside weakness modal)
        const footer = document.getElementById('weaknessFooter');
        footer.innerHTML = '';
        footer.style.display = 'flex';
        footer.style.justifyContent = 'center';
        footer.style.gap = '15px';

        const fixBtn = document.createElement('button');
        fixBtn.innerText = "Fix Weaknesses";
        fixBtn.className = "action-btn";
        fixBtn.style.background = "linear-gradient(135deg, #e67e22, #d35400)";
        fixBtn.style.marginRight = "10px";
        fixBtn.onclick = () => {
          document.getElementById('weaknessModal').style.display = 'none';
          toggleBuilderMode();
          // Optional: Scroll to builder or show message
          alert("Builder Mode Activated! Add cards to address the identified gaps.");
        };

        const closeBtn = document.createElement('button');
        closeBtn.innerText = "Close Report";
        closeBtn.className = "action-btn";
        closeBtn.style.background = "#555";
        closeBtn.onclick = () => document.getElementById('weaknessModal').style.display = 'none';

        footer.appendChild(fixBtn);
        footer.appendChild(closeBtn);
        modal.style.display = 'flex';
      });



      // HELPER: Normalize Level based on Rarity (Global Scope)
      // HELPER: Normalize Level based on Rarity (Global Scope)
      // HELPER: Normalize Level based on Rarity (Global Scope)
      function normalizeLevel(card) {
        let val = card.level || card.cardLevel || 0;

        // Debug check: If we see a level >= 14, it's likely already normalized (Elite level 15)
        if (val >= 14) return val;

        let rarity = (card.rarity || '').toLowerCase();

        // BASES: Common=1, Rare=3, Epic=6, Legendary=9, Champion=11
        // MAX RELATIVE: Rare (13-3+1 = 11?), Epic (13-6+1=8?), Legendary (13-9+1=5?)
        // Actually, let's use the API standard:
        // Rare Level 11 in API = Level 13 in game?
        // Let's rely on specific Max Relative thresholds.

        let base = 1;
        let maxRelative = 14;

        if (rarity === 'rare') { base = 3; maxRelative = 13; } // Rare Lvl 11 (API) + 2 = 13. Wait. base 3 means +2 offset? No. Lvl 1 = 3. Lvl 11 = 13. Offset is +2. So (val + base - 1). (11+3-1)=13. Correct.
        else if (rarity === 'epic') { base = 6; maxRelative = 10; } // Epic Lvl 8 (API) -> 8+6-1 = 13.
        else if (rarity === 'legendary') { base = 9; maxRelative = 7; } // Leg Lvl 5 (API) -> 5+9-1 = 13.
        else if (rarity === 'champion') { base = 11; maxRelative = 5; } // Champ Lvl 3 (API) -> 3+11-1 = 13.

        // If value is small enough to be relative for this rarity, normalize it.
        if (base > 1 && val <= maxRelative) {
          const normalized = val + (base - 1);
          // Sanity check: Don't exceed 15
          return Math.min(normalized, 15);
        }

        return val;
      }

      function log(...args) { console.log('[DeckHelper]', ...args); }

      // keyboard support: Enter triggers scan when in input
      input.addEventListener('keydown', (e) => { if (e.key === 'Enter') scan(); });

      btn.addEventListener('click', scan);
      demoBtn.addEventListener('click', () => { renderPlayer(DEMO_PLAYER); renderDeck({ cards: DEMO_DECK }); });

      async function scan() {
        const raw = input.value || '';
        const tag = raw.trim();
        output.style.display = 'block';
        if (!tag) { output.textContent = 'Please enter a player tag.'; return; }

        btn.disabled = true;
        output.textContent = 'Loading...';

        // Hard mock override removed to ensure real API fetch.

        const MAX_RETRIES = 3;
        let attempts = 0;
        let success = false;

        const clean = encodeURIComponent(tag.startsWith('#') ? tag : '#' + tag);
        const url = `${BASE_URL}/player/${clean}`;

        while (attempts < MAX_RETRIES && !success) {
          attempts++;
          if (attempts > 1) output.textContent = `Loading... (Attempt ${attempts}/${MAX_RETRIES})`;

          try {
            log('scan start', tag, 'attempt', attempts);
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), TIMEOUT_MS);
            log('fetch', url);
            const res = await fetch(url, { signal: controller.signal });
            clearTimeout(id);
            log('status', res.status);

            if (!res.ok) {
              const text = await res.text();
              let msg = `Error ${res.status}`;
              try {
                const json = JSON.parse(text);
                if (json.reason === 'notFound') msg = 'Player not found. Please check the tag.';
                else if (json.reason === 'accessDenied') msg = 'API Access Denied. Check server token.';
                else if (json.error) msg = json.error; // Backend sends 'error' key
                else if (json.message) msg = json.message;
              } catch (e) {
                msg += ': ' + text;
              }
              output.innerHTML = `<span style="color: #ff6b6b">${escapeHtml(msg)}</span><br><br><span style="font-size:12px;color:#ccc">Try a valid tag like #G9YV9GR8R</span>`;
              btn.disabled = false;
            }


            const data = await res.json();
            const playerTag = data.tag || data.playerTag || tag;
            document.querySelector('h1').textContent = `Player tag ${playerTag}`;
            document.querySelector('h1').style.color = '#D4AF37';

            log('data', data);
            renderPlayer(data);
            renderDeck(data);
            success = true;

            // Save to LocalStorage
            if (playerTag) {
              localStorage.setItem('cachedPlayerTag', playerTag);
            }

          } catch (err) {
            log('fetch error', err && err.name ? err.name : err);

            // Proper error handling instead of mock fallback
            output.innerHTML = `<span style="color: #ff6b6b">Connection Failed: ${err.message}</span>`;
            btn.disabled = false;

            if (attempts === MAX_RETRIES) {
              output.textContent = 'Request failed: ' + String(err) + '\n\nPossible causes:\n- Unstable internet connection\n- Timeout (try again)\n- Server unreachable\n\nYou can click Show Demo Deck to test the UI.';
            } else {
              // Small delay before retry
              await new Promise(resolve => setTimeout(resolve, 1500));
            }
          }
        }
        btn.disabled = false;
      }

      function extractCards(data) {
        if (!data) return [];
        if (Array.isArray(data.currentDeck) && data.currentDeck.length) return data.currentDeck;
        if (Array.isArray(data.cards)) return data.cards;
        if (Array.isArray(data.currentDeck?.cards)) return data.currentDeck.cards;
        for (const k of Object.keys(data || {})) {
          if (Array.isArray(data[k]) && data[k].length && data[k][0].name) return data[k];
        }
        return [];
      }

      function renderDeck(data) {
        const deck = extractCards(data);
        window.currentAppDeck = deck; // GLOBAL TRACKER FOR WEAKNESS CHECK
        const supportCards = data.currentDeckSupportCards || data.supportCards || [];
        const container = document.getElementById('deckContainer');
        container.innerHTML = '';

        if (!deck.length) {
          output.style.display = 'block';
          output.textContent = JSON.stringify(data, null, 2);
          return;
        }
        output.style.display = 'none';

        // Normal rendering: build 4x2 grid and support column
        const leftGrid = document.createElement('div');
        leftGrid.className = 'deck-grid';
        const supportCol = document.createElement('div');
        supportCol.className = 'support-column';

        for (let i = 0; i < Math.min(deck.length, 8); i++) {
          const card = deck[i];
          const cardEl = buildCardElement(card, i);
          leftGrid.appendChild(cardEl);
        }

        if (Array.isArray(supportCards) && supportCards.length) {
          const supEl = buildCardElement(supportCards[0], 'support');
          supEl.classList.add('support-card-item');
          supportCol.appendChild(supEl);
        }

        container.appendChild(leftGrid);
        container.appendChild(supportCol);

        // FORCE VISIBILITY OF BUTTONS
        // Improve Deck Button Removed
        const wBtn = document.getElementById('weaknessReportBtn');
        if (wBtn) wBtn.style.display = 'inline-block';
        const sBtn = document.getElementById('synergyBtn');
        if (sBtn) sBtn.style.display = 'inline-block';
      }

      // Use 2 Evo Slots (Index 0 and 1)
      function buildCardElement(card, i) {
        const title = card.name || card.card || `Card`;
        // FIX: Normalize Level
        const rawLevel = card.level || card.cardLevel || 1;
        const normalizedLevel = normalizeLevel(card);

        const elixir = card.elixirCost || '?';
        const imgUrl = card.iconUrls?.medium || '';
        const heroImg = card.iconUrls?.heroMedium || card.heroMedium;
        const evoImg = card.iconUrls?.evolutionMedium || card.evolutionMedium;

        // Logic: Slots 0 and 1 are Evo Slots
        const isEvoSlot = (typeof i === 'number' && (i === 0 || i === 1));
        // STRICT: Only show Evo Art if player has it unlocked (level > 0)
        const hasEvoUnlocked = (card.evolutionLevel || 0) > 0;
        const showEvoArt = isEvoSlot && hasEvoUnlocked && evoImg;

        const el = document.createElement('div');
        el.className = 'card-item';
        if (typeof i === 'number') el.style.animationDelay = `${i * 60}ms`;
        el.style.position = 'relative';

        // If placeholder layout enabled, show green box instead of real image
        let img;
        if (!PLACEHOLDER_LAYOUT) {
          img = document.createElement('img');
          img.alt = title;
          img.style.width = '100%';
          img.style.height = '100%';
          img.style.objectFit = 'contain';

          let src = imgUrl || '';

          // Rule: Use Evo Image ONLY if in Evo Slot (0 or 1) AND Unlocked
          if (showEvoArt) {
            src = evoImg;
            img.style.objectFit = 'cover';
          } else if (heroImg && !evoImg) {
            src = heroImg;
          }

          if (!isEvoSlot && imgUrl) {
            src = imgUrl;
          }

          img.src = src;
          const fallback = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="150" height="150"><rect fill="%237B3FE4" width="150" height="150"/><text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle" fill="%23D4AF37" font-size="12">' + escapeHtml(title.substring(0, 15)) + '</text></svg>';
          img.onerror = function () { this.onerror = null; this.src = fallback; };
        } else {
          img = document.createElement('div');
          img.className = 'placeholder-box';
          img.setAttribute('aria-label', title);
        }

        const info = document.createElement('div');
        info.className = 'card-info';
        info.style.position = 'absolute';
        info.style.top = '4px';
        info.style.width = '100%';
        info.style.display = 'flex';
        info.style.justifyContent = 'space-between';
        info.style.padding = '4px';
        info.style.fontWeight = 'bold';

        const elixirSpan = document.createElement('span');
        elixirSpan.style.background = '#7B3FE4';
        elixirSpan.style.color = '#fff'; // White text
        elixirSpan.style.padding = '4px 8px';
        elixirSpan.style.borderRadius = '6px';
        elixirSpan.style.fontSize = '14px'; // Bigger
        elixirSpan.style.textShadow = '0 1px 2px #000';
        elixirSpan.textContent = elixir;

        const levelSpan = document.createElement('span');
        levelSpan.style.background = '#000'; // Black bg
        levelSpan.style.color = '#f1c40f'; // Gold text
        levelSpan.style.padding = '6px 10px'; // Increased padding for visibility
        levelSpan.style.borderRadius = '6px';
        levelSpan.style.fontSize = '16px'; // Larger font for better readability
        levelSpan.style.border = '2px solid #f1c40f'; // Thicker border
        levelSpan.style.fontWeight = 'bold';
        levelSpan.textContent = 'Lv ' + normalizedLevel;

        info.appendChild(elixirSpan);
        info.appendChild(levelSpan);

        const nameBar = document.createElement('div');
        nameBar.className = 'card-name';
        nameBar.style.position = 'absolute';
        nameBar.style.bottom = '0';
        nameBar.style.width = '100%';
        nameBar.style.background = 'rgba(11,11,15,0.95)';
        nameBar.style.color = '#D4AF37';
        nameBar.style.padding = '4px';
        nameBar.style.textAlign = 'center';
        nameBar.style.fontSize = '12px';
        nameBar.style.fontWeight = 'bold';
        nameBar.style.overflow = 'hidden';
        nameBar.style.textOverflow = 'ellipsis';
        nameBar.style.whiteSpace = 'nowrap';
        nameBar.textContent = title;

        // badges
        if (heroImg) {
          const hb = document.createElement('img');
          hb.className = 'badge hero-badge';
          hb.src = heroImg;
          hb.alt = 'hero';
          hb.onerror = function () { this.style.display = 'none'; };
          el.appendChild(hb);
        }

        // Only show Evo Badge if in Evo Slot (0 or 1)
        if (showEvoArt) {
          if (card.evolutionLevel) {
            const eb = document.createElement('div');
            eb.className = 'badge evo-badge';
            eb.textContent = 'E' + card.evolutionLevel;
            el.appendChild(eb);
          } else if (evoImg && !heroImg) {
            // Fallback if no level but has image
            const eb2 = document.createElement('img');
            eb2.className = 'badge evo-badge';
            eb2.src = evoImg;
            eb2.alt = 'evo';
            eb2.style.display = 'none'; // text content usually better
            // el.appendChild(eb2);

            const ebText = document.createElement('div');
            ebText.className = 'badge evo-badge';
            ebText.textContent = 'EVO';
            el.appendChild(ebText);
          }
        }
        if (card.starLevel) {
          const sb = document.createElement('div');
          sb.className = 'badge star-badge';
          sb.textContent = 'â˜…' + card.starLevel;
          el.appendChild(sb);
        }

        el.appendChild(img);
        el.appendChild(info);
        el.appendChild(nameBar);
        return el;
      }

      let currentPlayerData = null;

      function renderPlayer(data) {
        currentPlayerData = data;
        window.currentPlayerData = data; // Expose to global for Matchup Analyzer
        const stats = document.getElementById('statsContainer');
        stats.innerHTML = '';
        if (!data) return;
        const name = data.name || data.playerName || 'Unknown';
        const tag = data.tag || data.playerTag || '';
        const level = data.expLevel ?? data.level ?? 'â€”';
        const trophies = data.trophies ?? 'â€”';
        const best = data.bestTrophies ?? 'â€”';
        const wins = data.wins ?? data.challengeCardsWon ?? 'â€”';
        const losses = data.losses ?? 'â€”';
        const clanName = data.clan?.name ?? '';

        const html = `
        <div class="stats-panel" style="display:block; text-align:center; margin-bottom: 30px; background: linear-gradient(135deg, rgba(20,20,30,0.95), rgba(0,0,0,0.9)); border: 1px solid rgba(212,175,55,0.2); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);">
            
            <!-- Header -->
            <div style="margin-bottom:25px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:15px;">
                <h2 style="margin:0; font-size:32px; color:var(--gold); text-shadow:0 0 15px rgba(212,175,55,0.3); letter-spacing:1px;">
                    ${escapeHtml(name)} 
                    <span style="font-size:16px; color:#888; font-weight:normal; vertical-align:middle; margin-left:10px;">${escapeHtml(tag)}</span>
                </h2>
                <div style="color:#bdc3c7; font-size:15px; margin-top:8px; display:flex; align-items:center; justify-content:center; gap:8px;">
                    <span style="font-size:18px;">ðŸ›¡ï¸</span> ${escapeHtml(clanName)}
                </div>
            </div>

            <!-- Stats Grid -->
            <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap:15px;">
                
                <!-- Level -->
                <div style="background:rgba(255,255,255,0.03); padding:15px 10px; border-radius:12px; border:1px solid rgba(255,255,255,0.05); transition:transform 0.2s;">
                    <div style="font-size:28px; margin-bottom:5px;">â­</div>
                    <div style="font-size:12px; color:#aaa; text-transform:uppercase; letter-spacing:1px;">Level</div>
                    <div style="font-size:22px; color:#fff; font-weight:bold; margin-top:5px;">${level}</div>
                </div>

                <!-- Trophies -->
                <div style="background:linear-gradient(180deg, rgba(241, 196, 15, 0.1), rgba(0,0,0,0)); padding:15px 10px; border-radius:12px; border:1px solid rgba(241, 196, 15, 0.2);">
                    <div style="font-size:28px; margin-bottom:5px; filter:drop-shadow(0 0 5px rgba(241,196,15,0.5));">ðŸ†</div>
                    <div style="font-size:12px; color:#e0c96c; text-transform:uppercase; letter-spacing:1px;">Trophies</div>
                    <div style="font-size:22px; color:#f1c40f; font-weight:bold; margin-top:5px;">${trophies}</div>
                </div>

                <!-- Best -->
                <div style="background:rgba(255,255,255,0.03); padding:15px 10px; border-radius:12px; border:1px solid rgba(255,255,255,0.05);">
                    <div style="font-size:28px; margin-bottom:5px;">ðŸ”ï¸</div>
                    <div style="font-size:12px; color:#aaa; text-transform:uppercase; letter-spacing:1px;">Best</div>
                    <div style="font-size:22px; color:#fff; font-weight:bold; margin-top:5px;">${best}</div>
                </div>

                <!-- Wins -->
                <div style="background:linear-gradient(180deg, rgba(46, 204, 113, 0.1), rgba(0,0,0,0)); padding:15px 10px; border-radius:12px; border:1px solid rgba(46, 204, 113, 0.2);">
                    <div style="font-size:28px; margin-bottom:5px;">âš”ï¸</div>
                    <div style="font-size:12px; color:#95e5b3; text-transform:uppercase; letter-spacing:1px;">Wins</div>
                    <div style="font-size:22px; color:#2ecc71; font-weight:bold; margin-top:5px;">${wins}</div>
                </div>

                <!-- Losses -->
                <div style="background:linear-gradient(180deg, rgba(231, 76, 60, 0.1), rgba(0,0,0,0)); padding:15px 10px; border-radius:12px; border:1px solid rgba(231, 76, 60, 0.2);">
                    <div style="font-size:28px; margin-bottom:5px;">&#128148;</div>
                    <div style="font-size:12px; color:#eaaead; text-transform:uppercase; letter-spacing:1px;">Losses</div>
                    <div style="font-size:22px; color:#e74c3c; font-weight:bold; margin-top:5px;">${losses}</div>
                </div>

            </div>
        </div>`;

        stats.innerHTML = html;

        // FORCE VISIBILITY OF NEW BUTTONS
        const weaknessBtn = document.getElementById('weaknessReportBtn');
        if (weaknessBtn) weaknessBtn.style.display = 'inline-block';

        const synergyBtn = document.getElementById('synergyBtn');
        if (synergyBtn) synergyBtn.style.display = 'inline-block';

        const subBtn = document.getElementById('substitutionsBtn');
        if (subBtn) subBtn.style.display = 'inline-block';

        const createNewBtn = document.getElementById('createNewBtn');
        if (createNewBtn) createNewBtn.style.display = 'inline-block';
        const buildBtn = document.getElementById('buildBtn');
        if (buildBtn) buildBtn.style.display = 'inline-block';
        const smartRefreshBtn = document.getElementById('smartRefreshBtn');
        if (smartRefreshBtn) smartRefreshBtn.style.display = 'inline-block';
      }

      function escapeHtml(s) { return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }


      // --- Deck Builder Logic with Expert AI ---
      let isBuilderMode = false;
      let builderDeck = [];
      let selectedPlaystyle = 'any'; // NEW: Track selected playstyle
      let excludedCards = new Set(); // NEW: Cards user wants to ban

      const buildBtn = document.getElementById('buildBtn');
      const autofillBtn = document.getElementById('autofillBtn');
      const builderControls = document.getElementById('builderControls');
      const cardPicker = document.getElementById('cardPicker');
      const aiStatus = document.getElementById('aiStatus');

      if (buildBtn) buildBtn.addEventListener('click', toggleBuilderMode);

      // Playstyle Button Handlers
      document.querySelectorAll('.playstyle-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // Remove active from all
          document.querySelectorAll('.playstyle-btn').forEach(b => b.classList.remove('active'));
          // Add active to clicked
          btn.classList.add('active');
          // Update selected playstyle
          selectedPlaystyle = btn.dataset.style;
        });
      });
      // Set default active
      document.querySelector('.playstyle-btn[data-style="any"]').classList.add('active');

      if (buildBtn) buildBtn.addEventListener('click', toggleBuilderMode);

      if (autofillBtn) {
        autofillBtn.addEventListener('click', () => {
          if (builderDeck.length >= 8) {
            alert('Deck is already full!');
            return;
          }
          runExpertAutofill();
        });
      }

      function toggleBuilderMode() {
        if (!currentPlayerData) {
          alert('Please scan a player first to load collection.');
          return;
        }
        isBuilderMode = !isBuilderMode;
        if (isBuilderMode) {
          buildBtn.textContent = 'Cancel Build';
          buildBtn.style.background = '#e74c3c';
          builderControls.style.display = 'block';
          document.getElementById('canImproveDeckBtn').style.display = 'none';
          document.getElementById('demoBtn').style.display = 'none';
          builderDeck = [];
          renderBuilderUI();
        } else {
          buildBtn.textContent = 'Build Deck';
          buildBtn.style.background = 'linear-gradient(135deg, #e67e22, #d35400)';
          builderControls.style.display = 'none';
          document.getElementById('canImproveDeckBtn').style.display = 'inline-block';
          document.getElementById('demoBtn').style.display = 'inline-block';
          renderDeck(currentPlayerData);
        }
      }

      function renderBuilderUI() {
        window.builderDeck = builderDeck; // Sync for Matchup Analyzer
        renderBuilderGrid();
        renderCardPicker();
      }

      function renderBuilderGrid() {
        const container = document.getElementById('deckContainer');
        container.innerHTML = '';
        const grid = document.createElement('div');
        grid.className = 'deck-grid';

        for (let i = 0; i < 8; i++) {
          if (i < builderDeck.length) {
            const card = builderDeck[i];
            const cardEl = buildCardElement(card, i);
            cardEl.style.cursor = 'pointer';
            cardEl.onclick = () => removeCardFromBuilder(i);
            const rm = document.createElement('div');
            rm.textContent = 'x';
            rm.style.cssText = 'position:absolute;top:-5px;right:-5px;background:red;color:white;border-radius:50%;width:20px;height:20px;text-align:center;line-height:20px;font-weight:bold;font-size:12px;';
            cardEl.appendChild(rm);
            grid.appendChild(cardEl);
          } else {
            const slot = document.createElement('div');
            slot.className = 'empty-slot';
            slot.textContent = '+';
            grid.appendChild(slot);
          }
        }
        container.appendChild(grid);

        // Support UI gap
        const support = document.createElement('div');
        support.className = 'support-column';
        container.appendChild(support);
      }

      function renderCardPicker() {
        cardPicker.innerHTML = '';
        if (!currentPlayerData) {
          cardPicker.innerHTML = '<div style="color:red">No player data loaded.</div>';
          return;
        }

        let allCards = [];
        if (currentPlayerData.cards && Array.isArray(currentPlayerData.cards)) {
          allCards = [...currentPlayerData.cards];
        } else if (currentPlayerData.currentDeck) {
          // Fallback for limited data
          allCards = [...currentPlayerData.currentDeck];
        }

        if (allCards.length === 0) {
          cardPicker.innerHTML = '<div style="color:orange">No cards found in player profile.</div>';
          return;
        }

        // Sort by Normalized Level
        allCards.sort((a, b) => {
          return normalizeLevel(b) - normalizeLevel(a);
        });

        allCards.forEach(card => {
          try {
            const isSelected = builderDeck.find(c => c.name === card.name);
            const isExcluded = excludedCards.has(card.name);

            const wrapper = document.createElement('div');
            wrapper.style.position = 'relative';
            wrapper.style.display = 'inline-block';

            const imgUrl = card.iconUrls?.medium;
            const el = document.createElement('img');
            el.src = imgUrl;
            el.className = 'picker-card';
            if (isSelected) el.classList.add('selected');
            if (isExcluded) {
              el.style.opacity = '0.3';
              el.style.filter = 'grayscale(100%)';
            }

            // Left click: Add to deck
            el.onclick = () => {
              if (!isExcluded) addCardToBuilder(card);
            };

            // Right click: Exclude/Include
            el.oncontextmenu = (e) => {
              e.preventDefault();
              if (excludedCards.has(card.name)) {
                excludedCards.delete(card.name);
              } else {
                excludedCards.add(card.name);
              }
              renderCardPicker();
            };

            wrapper.appendChild(el);

            // Exclusion indicator
            if (isExcluded) {
              const banIcon = document.createElement('div');
              banIcon.textContent = 'ðŸš«';
              banIcon.style.cssText = 'position:absolute; top:5px; right:5px; font-size:20px; pointer-events:none;';
              wrapper.appendChild(banIcon);
            }

            // Level Badge (Tiny)
            const lvlBadge = document.createElement('div');
            lvlBadge.textContent = normalizeLevel(card);
            lvlBadge.style.cssText = 'position:absolute; bottom:2px; right:2px; background:black; color:gold; font-size:10px; padding:1px 3px; border-radius:4px;';
            wrapper.appendChild(lvlBadge);

            cardPicker.appendChild(wrapper);
          } catch (err) {
            console.error('Error rendering card in picker:', card, err);
          }
        });
      }

      // --- Stat Metrics ---
      // Simple heuristic values (0-10) for demo
      const CARD_METRICS = {
        'Hog Rider': { off: 9, def: 0 }, 'Giant': { off: 8, def: 2 }, 'Golem': { off: 9, def: 1 },
        'Musketeer': { off: 6, def: 8 }, 'Archers': { off: 4, def: 6 }, 'Knight': { off: 3, def: 8 },
        'Ice Golem': { off: 1, def: 8 }, 'Skeletons': { off: 1, def: 5 }, 'Ice Spirit': { off: 1, def: 6 },
        'Cannon': { off: 0, def: 9 }, 'Tesla': { off: 0, def: 10 }, 'Inferno Tower': { off: 1, def: 10 },
        'Fireball': { off: 6, def: 7 }, 'Zap': { off: 4, def: 6 }, 'The Log': { off: 2, def: 8 },
        'Goblin Barrel': { off: 9, def: 0 }, 'Princess': { off: 6, def: 5 }, 'Rocket': { off: 8, def: 5 },
        'P.E.K.K.A': { off: 7, def: 10 }, 'Mega Knight': { off: 6, def: 9 }, 'Sparky': { off: 10, def: 4 },
        'Balloon': { off: 10, def: 0 }, 'Lava Hound': { off: 7, def: 2 }, 'Miner': { off: 6, def: 4 },
        'Electro Wizard': { off: 6, def: 8 }, 'Inferno Dragon': { off: 7, def: 9 }, 'Magic Archer': { off: 7, def: 5 },
        'Lumberjack': { off: 8, def: 4 }, 'Night Witch': { off: 6, def: 4 }, 'Royal Ghost': { off: 6, def: 5 },
        'Bandit': { off: 7, def: 4 }, 'Fisherman': { off: 1, def: 9 }, 'Mother Witch': { off: 5, def: 6 },
        'Royal Giant': { off: 9, def: 1 }, 'Elite Barbarians': { off: 9, def: 6 }, 'Royal Recruits': { off: 5, def: 10 },
        'Goblin Giant': { off: 8, def: 3 }, 'Electro Giant': { off: 9, def: 5 }, 'X-Bow': { off: 9, def: 7 },
        'Mortar': { off: 7, def: 7 }, 'Graveyard': { off: 9, def: 1 }, 'Drill': { off: 8, def: 3 },
        'Wall Breakers': { off: 8, def: 0 }, 'Battle Ram': { off: 7, def: 3 }, 'Ram Rider': { off: 8, def: 6 },
        'Skeleton Barrel': { off: 7, def: 1 }, 'Flying Machine': { off: 6, def: 5 }, 'Zappies': { off: 2, def: 8 },
        'Mini P.E.K.K.A': { off: 7, def: 8 }, 'Valkyrie': { off: 4, def: 9 }, 'Executioner': { off: 5, def: 9 },
        'Bowler': { off: 4, def: 9 }, 'Dark Prince': { off: 6, def: 7 }, 'Baby Dragon': { off: 5, def: 6 },
        'Hunter': { off: 6, def: 9 }, 'Witch': { off: 5, def: 5 }, 'Wizard': { off: 6, def: 4 },
        'Prince': { off: 8, def: 6 }, 'Guards': { off: 2, def: 9 }, 'Goblin Gang': { off: 5, def: 5 },
        'Minions': { off: 5, def: 4 }, 'Minion Horde': { off: 8, def: 4 }, 'Bats': { off: 4, def: 5 },
        'Spear Goblins': { off: 3, def: 3 }, 'Goblin Gang': { off: 5, def: 5 }, 'Rascals': { off: 5, def: 8 }
      };

      function updateStats() {
        const statsPanel = document.getElementById('statsPanel');
        if (builderDeck.length === 0) {
          statsPanel.style.display = 'none';
          return;
        }
        statsPanel.style.display = 'grid';

        // 1. Avg Elixir & Cycle
        const costs = builderDeck.map(c => c.elixirCost || 3);
        const totalCost = costs.reduce((a, b) => a + b, 0);
        const avg = (totalCost / (builderDeck.length || 1)).toFixed(1);

        const sortedCosts = [...costs].sort((a, b) => a - b);
        const cycle = sortedCosts.slice(0, 4).reduce((a, b) => a + b, 0);

        document.getElementById('avgElixir').textContent = avg;
        document.getElementById('cycleCost').textContent = cycle;

        // 2. Offense / Defense
        let offSum = 0, defSum = 0;
        builderDeck.forEach(c => {
          let m = CARD_METRICS[c.name];

          // If no manual metric, derive from Role
          if (!m) {
            m = { off: 4, def: 5 }; // Default support
            if (CARD_ROLES.winCon.includes(c.name)) m = { off: 9, def: 1 };
            else if (CARD_ROLES.building.includes(c.name)) m = { off: 1, def: 9 };
            else if (CARD_ROLES.spellBig.includes(c.name)) m = { off: 7, def: 5 };
            else if (CARD_ROLES.spellSmall.includes(c.name)) m = { off: 3, def: 7 };
            else if (CARD_ROLES.tankKiller.includes(c.name)) m = { off: 6, def: 9 };
            else if (CARD_ROLES.airCounter.includes(c.name)) m = { off: 5, def: 6 };
          }

          offSum += m.off;
          defSum += m.def;
        });

        // Max possible is approx 70-80 for a full deck, scale to 100
        // Lower denominator to make 100 reachable (approx 45 points = 100%)
        const offPct = Math.min(100, Math.round((offSum / 40) * 100));
        const defPct = Math.min(100, Math.round((defSum / 40) * 100));

        // UPDATE: Show the PERCENTAGE (0-100) not the raw sum
        document.getElementById('offScore').textContent = offPct;
        document.getElementById('defScore').textContent = defPct;

        document.getElementById('offBar').style.width = `${offPct}%`;
        document.getElementById('defBar').style.width = `${defPct}%`;

        // 3. Meta Score (Win Rate Sim)
        // STRICT MODE: Earn your S-Tier.
        // Base 30 (F-Tier)
        let metaScore = 30;

        // A. Level Factor
        const avgLevel = builderDeck.reduce((a, c) => a + (c.level || 0), 0) / (builderDeck.length || 1);
        metaScore += (avgLevel - 9) * 4;

        // B. Synergy Factor
        let synCount = 0;
        for (const c1 of builderDeck) {
          for (const c2 of builderDeck) {
            if (c1 === c2) continue;
            // Named Synergy
            for (const pair of SYNERGIES) {
              if (pair.includes(c1.name) && pair.includes(c2.name)) {
                synCount += 4; // Solid bonus
                break;
              }
            }
          }
        }
        metaScore += Math.min(25, synCount); // Cap at 25 (Need ~6 pairs for max)

        // C. Tactical Integrity (Strict)
        const roles = getDeckRoles(builderDeck);

        // 1. Spell Balance (Strict: Need BOTH for +10)
        if (roles.hasSmallSpell && roles.hasBigSpell) metaScore += 10;
        else if (roles.hasSmallSpell || roles.hasBigSpell) metaScore += 2; // Participation trophy reduced

        // 2. Win Condition (Strict: Need valid WinCon)
        if (roles.hasWinCon) metaScore += 10;
        else metaScore -= 10; // Penalty for no WC

        // 3. Defense Coverage (Strict: Reset + Air + Killer)
        const hasAir = builderDeck.some(c => getCardRole(c.name).includes('airCounter'));
        const hasKiller = builderDeck.some(c => getCardRole(c.name).includes('tankKiller') || c.name === 'Inferno Tower' || c.name === 'Inferno Dragon');

        const resetCards = ['Zap', 'Electro Wizard', 'Electro Spirit', 'Lightning', 'Freeze', 'Giant Snowball', 'Zappies', 'E-Dragon'];
        const hasReset = builderDeck.some(c => resetCards.includes(c.name));

        if (hasAir) metaScore += 5;
        if (hasKiller) metaScore += 5;
        if (hasReset) metaScore += 5;

        // 4. Elixir Curve
        const eCurveCosts = builderDeck.map(c => c.elixirCost || 3);
        const total = eCurveCosts.reduce((a, b) => a + b, 0);
        const avgEl = total / 8;
        if (avgEl >= 2.6 && avgEl <= 4.1) metaScore += 5;
        else metaScore -= 5;

        // 5. Evolution Bonus
        const hasEvo = builderDeck.some(c => (c.evolutionLevel || 0) > 0);
        if (hasEvo) metaScore += 5;

        // Cap at 100
        metaScore = Math.min(100, Math.round(metaScore));

        // Scale 0-100 logic
        // Approx 20-30 syn points is "good" -> 100%
        const synPct = Math.min(100, Math.round(synCount * 4));
        document.getElementById('synScore').textContent = Math.round(synPct);
        document.getElementById('synBar').style.width = `${synPct}%`;

        // Tier
        let tier = 'C';
        if (metaScore > 80) tier = 'S+';
        else if (metaScore > 70) tier = 'A';
        else if (metaScore > 60) tier = 'B';

        document.getElementById('metaScoreBadge').textContent = `Meta Score: ${Math.round(metaScore)} (${tier})`;
        document.getElementById('metaScoreBadge').style.color = metaScore > 75 ? '#2ecc71' : (metaScore > 60 ? '#f1c40f' : '#e74c3c');
        document.getElementById('metaScoreBadge').style.borderColor = document.getElementById('metaScoreBadge').style.color;

        // 6. WIN RATE PREDICTION (NEW!)
        // Sophisticated model based on multiple factors
        let winRate = 50; // Base 50% win rate

        // Factor 1: Average Level (Â±10%)
        // Higher levels = higher win rate
        const levelBonus = Math.min(10, (avgLevel - 11) * 2.5); // +2.5% per level above 11
        winRate += levelBonus;

        // Factor 2: Synergy (Â±8%)
        // More synergies = better combos = higher win rate
        const synergyBonus = Math.min(8, synCount * 0.4); // +0.4% per synergy point
        winRate += synergyBonus;

        // Factor 3: Deck Completeness (Â±12%)
        let completenessBonus = 0;
        if (roles.hasWinCon) completenessBonus += 4;
        if (roles.hasSmallSpell && roles.hasBigSpell) completenessBonus += 4;
        if (hasAir) completenessBonus += 2;
        if (hasKiller) completenessBonus += 2;
        winRate += completenessBonus;

        // Factor 4: Meta Quality (Â±5%)
        // Using S-tier cards increases win rate
        let metaBonus = (metaScore - 60) * 0.1; //  +0.1% per point above 60
        metaBonus = Math.max(-5, Math.min(5, metaBonus));
        winRate += metaBonus;

        // Factor 5: Elixir Efficiency (Â±3%)
        // Optimal elixir cost improves win rate
        let elixirBonus = 0;
        if (avgEl >= 2.6 && avgEl <= 4.0) elixirBonus = 3; // Perfect range
        else if (avgEl < 2.3 || avgEl > 4.5) elixirBonus = -3; // Too extreme
        winRate += elixirBonus;

        // Factor 6: Archetype Purity (Â±2%)
        // Focused decks perform better
        const archetypeBonus = synCount >= 15 ? 2 : 0;
        winRate += archetypeBonus;

        // Cap win rate between 40-65% (realistic range)
        winRate = Math.max(40, Math.min(65, Math.round(winRate)));

        // Display Win Rate
        const winRateDisplay = document.getElementById('winRateDisplay');
        const winRateFactors = document.getElementById('winRateFactors');

        if (winRateDisplay) {
          winRateDisplay.textContent = `${winRate}%`;
          winRateDisplay.style.color = winRate >= 55 ? '#2ecc71' : winRate >= 50 ? '#f1c40f' : '#e74c3c';
          winRateDisplay.style.textShadow = `0 0 10px ${winRate >= 55 ? 'rgba(46, 204, 113, 0.5)' : winRate >= 50 ? 'rgba(241, 196, 15, 0.5)' : 'rgba(231, 76, 60, 0.5)'}`;
        }

        if (winRateFactors) {
          const factors = [];
          if (levelBonus > 0) factors.push(`+${levelBonus.toFixed(1)}% Levels`);
          if (synergyBonus > 0) factors.push(`+${synergyBonus.toFixed(1)}% Synergy`);
          if (completenessBonus > 0) factors.push(`+${completenessBonus}% Complete`);
          winRateFactors.textContent = factors.join(' â€¢ ') || 'Based on deck analysis';
        }
      }

      function addCardToBuilder(card) {
        if (builderDeck.length >= 8) return;
        if (builderDeck.find(c => c.name === card.name)) return;
        builderDeck.push(card);
        renderBuilderUI();
        updateStats(); // <--- Update on change
      }

      function removeCardFromBuilder(index) {
        builderDeck.splice(index, 1);
        renderBuilderUI();
        updateStats(); // <--- Update on change
      }


      // --- Expert Knowledge Base ---
      const CARD_ROLES = {
        winCon: ['Hog Rider', 'Giant', 'Golem', 'Royal Giant', 'Balloon', 'Goblin Barrel', 'Miner', 'Graveyard', 'Lava Hound', 'X-Bow', 'Mortar', 'Ram Rider', 'Elixir Golem', 'Electro Giant', 'Royal Hogs', 'Three Musketeers', 'Sparky', 'Battle Ram', 'Skeleton Barrel', 'Wall Breakers', 'Drill'],
        spellSmall: ['Zap', 'The Log', 'Snowball', 'Arrows', 'Barbarian Barrel', 'Tornado', 'Royal Delivery'],
        spellBig: ['Fireball', 'Poison', 'Rocket', 'Lightning', 'Earthquake', 'Void'],
        building: ['Cannon', 'Tesla', 'Inferno Tower', 'Bomb Tower', 'Tombstone', 'Goblin Cage', 'Furnace', 'Barbarian Hut', 'Goblin Hut', 'Elixir Collector'],
        // MASSIVELY EXPANDED AIR DEFENSE LIST - 35+ cards!
        airCounter: [
          // S-Tier Air Defense
          'Musketeer', 'Electro Wizard', 'Mega Minion', 'Bats', 'Minions',
          'Baby Dragon', 'Inferno Dragon', 'Flying Machine', 'Magic Archer',
          // A-Tier Air Defense  
          'Archers', 'Firecracker', 'Princess', 'Dart Goblin', 'Spear Goblins',
          'Hunter', 'Mother Witch', 'Ice Wizard',
          // B-Tier Air Defense (Situational but valid)
          'Wizard', 'Executioner', 'Witch', 'Night Witch',
          'Tesla', 'Inferno Tower', 'Cannon', 'Bomb Tower',
          // C-Tier Air Defense (Can target air)
          'Arrows', 'Fireball', 'Poison', 'Lightning', 'Zap',
          'Rocket', 'Tornado', 'Snowball',
          // D-Tier (Weak but technically targets air)
          'Minion Horde', 'Skeleton Dragons', 'Phoenix',
          'Electro Dragon', 'Balloon', 'Lava Hound',
          // Special mentions
          'Queen', 'Little Prince', 'Archer Queen', 'Golden Knight'
        ],
        miniTank: ['Knight', 'Valkyrie', 'Ice Golem', 'Mini P.E.K.K.A', 'Royal Ghost', 'Bandit', 'Dark Prince', 'Golden Knight', 'Skeleton King', 'Mighty Miner', 'Fisherman', 'Lumberjack', 'Prince', 'Bowler', 'Mega Knight', 'Giant Skeleton', 'Monk', 'Cannon Cart'],
        tankKiller: ['Mini P.E.K.K.A', 'P.E.K.K.A', 'Prince', 'Lumberjack', 'Elite Barbarians', 'Inferno Dragon', 'Mighty Miner', 'Hunter', 'Barbarians']
      };

      const SYNERGIES = [
        // Hog
        ['Hog Rider', 'Earthquake'], ['Hog Rider', 'Ice Golem'], ['Hog Rider', 'Firecracker'],
        ['Hog Rider', 'Musketeer'], ['Hog Rider', 'The Log'], ['Hog Rider', 'Cannon'],
        ['Hog Rider', 'Valkyrie'], ['Hog Rider', 'Tesla'],
        // Golem
        ['Golem', 'Night Witch'], ['Golem', 'Lightning'], ['Golem', 'Baby Dragon'],
        ['Golem', 'Lumberjack'], ['Golem', 'Mega Minion'], ['Golem', 'Tornado'],
        ['Golem', 'Electro Dragon'], ['Golem', 'Skeleton King'],
        // Air
        ['Lava Hound', 'Balloon'], ['Lava Hound', 'Mega Minion'], ['Lava Hound', 'Inferno Dragon'],
        ['Lava Hound', 'Skeleton Dragons'], ['Lava Hound', 'Fireball'], ['Lava Hound', 'Zap'],
        ['Lava Hound', 'Barbarians'], ['Balloon', 'Lumberjack'], ['Balloon', 'Miner'], ['Balloon', 'Freeze'],
        // Giant variants
        ['Giant', 'Witch'], ['Giant', 'Prince'], ['Giant', 'Miner'], ['Giant', 'Sparky'],
        ['Goblin Giant', 'Sparky'], ['Goblin Giant', 'Rage'], ['Goblin Giant', 'Dark Prince'],
        ['Electro Giant', 'Tornado'], ['Electro Giant', 'Lightning'], ['Electro Giant', 'Golden Knight'],
        ['Royal Giant', 'Fisherman'], ['Royal Giant', 'Mother Witch'], ['Royal Giant', 'Lightning'],
        ['Royal Giant', 'Hunter'], ['Royal Giant', 'Electro Spirit'],
        // Cycle / Bait
        ['Goblin Barrel', 'Princess'], ['Goblin Barrel', 'Goblin Gang'], ['Goblin Barrel', 'Dart Goblin'],
        ['Goblin Barrel', 'Rocket'], ['Goblin Barrel', 'Knight'], ['Goblin Barrel', 'Inferno Tower'],
        ['Goblin Barrel', 'Skeleton King'], ['Skeleton Barrel', 'Mega Knight'],
        ['Wall Breakers', 'Miner'], ['Wall Breakers', 'Magic Archer'],
        ['Goblin Drill', 'Bomber'], ['Goblin Drill', 'Fireball'], ['Goblin Drill', 'Wall Breakers'],
        // Siege
        ['X-Bow', 'Tesla'], ['X-Bow', 'Knight'], ['X-Bow', 'Archers'], ['X-Bow', 'The Log'],
        ['Mortar', 'Skeleton King'], ['Mortar', 'Miner'], ['Mortar', 'Dart Goblin'],
        // Control
        ['Graveyard', 'Poison'], ['Graveyard', 'Baby Dragon'], ['Graveyard', 'Knight'],
        ['Graveyard', 'Ice Wizard'], ['Graveyard', 'Tornado'], ['Graveyard', 'Bowler'],
        ['Graveyard', 'Skeleton King'], ['Graveyard', 'Barbarian Barrel'],
        // Bridgespam
        ['P.E.K.K.A', 'Battle Ram'], ['P.E.K.K.A', 'Electro Wizard'], ['P.E.K.K.A', 'Bandit'],
        ['P.E.K.K.A', 'Royal Ghost'], ['P.E.K.K.A', 'Magic Archer'],
        ['Mega Knight', 'Bats'], ['Mega Knight', 'Inferno Dragon'], ['Mega Knight', 'Wall Breakers'],
        ['Mega Knight', 'Ram Rider'], ['Mega Knight', 'Bandit'],
        ['Royal Hogs', 'Royal Recruits'], ['Royal Hogs', 'Fireball'], ['Royal Hogs', 'Flying Machine'],
        ['Elite Barbarians', 'Rage'], ['Elite Barbarians', 'Heal Spirit'],
        // Utility
        ['Tornado', 'Executioner'], ['Tornado', 'Ice Wizard'], ['Tornado', 'Baby Dragon'],
        ['Tornado', 'Magic Archer'], ['Tornado', 'Sparky'],
        ['Miner', 'Poison'], ['Miner', 'Magic Archer'],
        // Added Meta Synergies (Genius Mode)
        ['Lava Hound', 'Flying Machine'], ['Lava Hound', 'Skeleton Dragons'],
        ['Golem', 'Elite Barbarians'], ['Golem', 'Dark Prince'],
        ['Royal Giant', 'Executioner'], ['Royal Giant', 'Zappies'],
        ['Goblin Giant', 'Prince'], ['Goblin Giant', 'Rage'],
        ['Electro Giant', 'Bowler'], ['Electro Giant', 'Bomber'],
        ['Hog Rider', 'Firecracker'], ['Hog Rider', 'Bomb Tower']
      ];

      const ARCHETYPES = [
        { name: '2.6 Hog Cycle', cards: ['Hog Rider', 'Musketeer', 'Ice Golem', 'Ice Spirit', 'Skeletons', 'Cannon', 'Fireball', 'The Log'] },
        { name: 'Log Bait', cards: ['Goblin Barrel', 'Princess', 'Goblin Gang', 'Rocket', 'Knight', 'Inferno Tower', 'Ice Spirit', 'The Log'] },
        { name: 'Golem Beatdown', cards: ['Golem', 'Night Witch', 'Baby Dragon', 'Lightning', 'Mega Minion', 'Barbarian Barrel', 'Tornado', 'Lumberjack'] },
        { name: 'Lavaloon', cards: ['Lava Hound', 'Balloon', 'Mega Minion', 'Minions', 'Barbarians', 'Zap', 'Fireball', 'Tombstone'] },
        { name: 'Pekka Bridge Spam', cards: ['P.E.K.K.A', 'Battle Ram', 'Bandit', 'Royal Ghost', 'Electro Wizard', 'Magic Archer', 'Zap', 'Poison'] },
        { name: 'Royal Giant FishBoy', cards: ['Royal Giant', 'Fisherman', 'Mother Witch', 'Lightning', 'The Log', 'Skeletons', 'Electro Spirit', 'Mega Minion'] },
        { name: 'Splashyard', cards: ['Graveyard', 'Baby Dragon', 'Ice Wizard', 'Tornado', 'Valkyrie', 'Poison', 'Barbarian Barrel', 'Tombstone'] },
        { name: 'Recruits Hogs', cards: ['Royal Recruits', 'Royal Hogs', 'Flying Machine', 'Goblin Cage', 'Fireball', 'Barbarian Barrel', 'Zappies', 'Electro Spirit'] },
        { name: 'E-Giant Mirror', cards: ['Electro Giant', 'Lightning', 'Tornado', 'Golden Knight', 'Bomber', 'Cannon', 'Mirror', 'Barbarian Barrel'] },
        { name: 'Goblin Drill Cycle', cards: ['Goblin Drill', 'Wall Breakers', 'Bomber', 'Fireball', 'Tesla', 'Skeletons', 'The Log', 'Knight'] },
        { name: 'Mega Knight Bait', cards: ['Mega Knight', 'Skeleton Barrel', 'Miner', 'Goblin Gang', 'Spear Goblins', 'Bats', 'Zap', 'Inferno Dragon'] },
        { name: 'Sparky Goblin Giant', cards: ['Goblin Giant', 'Sparky', 'Rage', 'Dark Prince', 'Electro Wizard', 'Mega Minion', 'Zap', 'Heal Spirit'] },
        { name: 'X-Bow 3.0', cards: ['X-Bow', 'Tesla', 'Knight', 'Archers', 'Skeletons', 'Electro Spirit', 'Fireball', 'The Log'] },
        { name: 'Miner Control', cards: ['Miner', 'Poison', 'Wall Breakers', 'Magic Archer', 'Bomb Tower', 'Skeletons', 'The Log', 'Knight'] }
      ];

      // GLOBAL HISTORY TRACKER
      let cardUsageHistory = {};
      let previousDeckNames = new Set();
      let generationCount = 0;

      async function runExpertAutofill() {
        console.log("--- AI AUTOFILL START ---");

        // 1. Identify Playstyle & Archetype
        const selectedPlaystyle = document.querySelector('.playstyle-btn.active').dataset.style;
        console.log("Selected Playstyle:", selectedPlaystyle);

        // FIX: Calculate Peak Level for dynamic scoring
        let playerPeakLevel = 14;
        if (currentPlayerData && currentPlayerData.cards) {
          playerPeakLevel = Math.max(...currentPlayerData.cards.map(c => normalizeLevel(c)));
          console.log("Player Peak Level detected:", playerPeakLevel);
        }

        // INCREMENT GENERATION COUNT
        generationCount++;
        // Decay history every 3 generations so we don't run out of cards eventually
        if (generationCount % 3 === 0) {
          console.log("Clearing Card History (Fresh Start)");
          cardUsageHistory = {};
        }

        // 2. Score all available cards
        // Filter out cards already in deck
        const currentNames = new Set(builderDeck.map(c => c.name));

        if (builderDeck.length >= 8) return;

        autofillBtn.disabled = true;
        const originalText = autofillBtn.textContent;
        autofillBtn.textContent = 'AI Processing...';
        autofillBtn.style.background = '#8e44ad'; // Purple

        const slotsToFill = 8 - builderDeck.length;

        // Visual Scanner Steps (Simulate deep thought)
        const steps = [
          'Connecting to RoyaleAPI Database...',
          'Scanning Global Meta Decks...',
          'Analyzing Card Synergies...',
          'Optimizing for Card Levels...',
          'Finalizing Deck Structure...'
        ];

        for (const step of steps) {
          aiStatus.textContent = step;
          await new Promise(r => setTimeout(r, 800)); // 800ms per step = 4 sec total thought
        }

        // --- Core Logic ---

        // 1. Identify Archetype Strategy
        let bestArchetype = null;
        let maxMatch = 0;

        for (const arch of ARCHETYPES) {
          const matchCount = builderDeck.filter(c => arch.cards.includes(c.name)).length;
          if (matchCount > maxMatch && matchCount > 0) {
            maxMatch = matchCount;
            bestArchetype = arch;
          }
        }

        if (bestArchetype) aiStatus.textContent = `Match Found: ${bestArchetype.name} Strategy`;
        else aiStatus.textContent = `Building Custom Meta Deck...`;

        await new Promise(r => setTimeout(r, 1000));

        // 2. Candidate Selection (Level Aware)
        // We will score every card in the collection
        // Score = (Synergy * 5) + (ArchetypeFit * 10) + (CardLevel * 15) <--- HUGE LEVEL WEIGHT

        let allCards = [];
        if (currentPlayerData && currentPlayerData.cards) {
          allCards = [...currentPlayerData.cards];
        }

        // Calculate Max Level in collection for relative scoring
        const maxLevelInCollection = allCards.reduce((max, c) => Math.max(max, normalizeLevel(c)), 0);

        const candidates = allCards.filter(c => !currentNames.has(c.name) && !excludedCards.has(c.name));

        // HARDENING: FILTER CANDIDATES FOR STRICT COMPOSITION
        // 1. Count current Win Cons
        const currentWinCons = builderDeck.filter(c => CARD_ROLES.winCon.includes(c.name)).length;
        const WIN_CON_LIMIT = 2;

        const filteredCandidates = candidates.filter(card => {
          // If card is Win Con, only allow if under limit
          if (CARD_ROLES.winCon.includes(card.name)) {
            if (currentWinCons >= WIN_CON_LIMIT) return false;
          }
          return true;
        });

        const scoredCandidates = filteredCandidates.map(card => {
          let score = 0;
          const normLevel = normalizeLevel(card);

          // A. LEVEL SCORE (Crucial)
          // Penalty for being under max level.
          // e.g. Max 14. Card is 14 -> 0 penalty. Card is 9 -> -5 * ? penalty.
          const levelDiff = maxLevelInCollection - normLevel;

          // Non-linear penalty: Being 1-2 levels under is ok (-20). Being 5 levels under is FATAL (-200).
          score -= (levelDiff * 15);

          // Bonus for absolute high level (Elite/Max)
          if (normLevel >= 14) score += 50;

          // B. SYNERGY SCORE
          const synCount = SYNERGIES.filter(pair =>
            pair.includes(card.name) && builderDeck.some(dc => pair.includes(dc.name))
          ).length;
          score += (synCount * 30); // Strong synergy weight

          // C. ARCHETYPE FIT
          if (bestArchetype && bestArchetype.cards.includes(card.name)) {
            score += 40;
          }

          // D. ROLE FILLING (Simple heuristic)
          // If deck needs air defense, boost air defense cards
          const roles = getDeckRoles(builderDeck); // Current roles
          const cardRoles = getCardRole(card.name);

          if (!roles.hasWinCon && cardRoles.includes('winCon')) score += 100; // Must have wincon
          if (!roles.hasSmallSpell && cardRoles.includes('spellSmall')) score += 80;
          if (!roles.hasBigSpell && cardRoles.includes('spellBig')) score += 80;
          if (builderDeck.length > 4 && !getDeckRoles(builderDeck).hasBuilding && cardRoles.includes('building')) score += 50;

          // E. META & TIER LIST
          // Boost S+ Tier cards slightly
          if (META_QUALITY[card.name]) {
            score += (META_QUALITY[card.name] / 10); // +10 to +15 points
          }

          return { card, score };
        });

        // Sort by Score Descending
        scoredCandidates.sort((a, b) => b.score - a.score);

        // Pick Top N with Dynamic Role Checking (Hardening Loop)
        const topPicks = [];
        let netWinCons = currentWinCons;

        for (const candidate of scoredCandidates) {
          if (topPicks.length >= slotsToFill) break;

          const isWinCon = CARD_ROLES.winCon.includes(candidate.card.name);

          // STRICT LIMIT: Max 2 Win Conditions
          if (isWinCon && netWinCons >= 2) continue;

          topPicks.push(candidate.card);
          if (isWinCon) netWinCons++;
        }

        // Add them
        topPicks.forEach(c => {
          builderDeck.push(c);
          updateStats();
        });

        renderBuilderUI();

        autofillBtn.textContent = originalText;
        autofillBtn.disabled = false;
        autofillBtn.style.background = '';



        // 5. DECKSHOP VERIFICATION
        // 5. DECKSHOP VERIFICATION
        const checkBtn = document.getElementById('checkDeckBtn');
        const deckCheckResult = document.getElementById('deckCheckResult');

        if (checkBtn) {
          checkBtn.onclick = async () => {
            if (!builderDeck || builderDeck.length === 0) {
              alert("Please generate a deck first!");
              return;
            }

            checkBtn.disabled = true;
            checkBtn.textContent = "â³ Verifying with DeckShop...";
            deckCheckResult.style.display = 'block';
            deckCheckResult.innerHTML = '<div style="text-align:center;color:#ccc;">Connecting to DeckShop Pro...</div>';

            try {
              // Send just the names, backend handles slugs (and overrides)
              const deckNames = builderDeck.map(c => c.name);

              const res = await fetch('/api/check-deck', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ deck: deckNames })
              });

              if (!res.ok) {
                const errData = await res.json().catch(() => ({}));
                const error = new Error(errData.error || res.statusText || "Verification failed");
                if (errData.debugImage) error.debugImage = errData.debugImage;
                throw error;
              }

              const data = await res.json();
              const evalData = data.evaluation || {};

              let html = '<div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">';

              // Helper for colors
              const getColor = (val) => {
                const v = (val || '').toLowerCase();
                if (v.includes('godly') || v.includes('legendary')) return '#e74c3c'; // Red/Hot for Godly? Or Green? Usually Gold/Red. Let's use Deckshop Colors.
                // Actually DeckShop: Godly = Purple/Pink? Good = Green.
                // Let's stick to: Good/Great/Godly = Green/Teal. Bad/Mediocre = Orange/Red.
                if (v.includes('good') || v.includes('great') || v.includes('godly')) return '#2ecc71';
                if (v.includes('mediocre') || v.includes('bad')) return '#e74c3c';
                return '#f1c40f'; // Warning
              };

              for (const [key, val] of Object.entries(evalData)) {
                html += `
                        <div style="background:rgba(0,0,0,0.3); padding:8px; border-radius:6px; display:flex; justify-content:space-between;">
                            <span style="color:#aaa; font-size:12px;">${key.toUpperCase()}</span>
                            <span style="font-weight:bold; color:${getColor(val)}">${val}</span>
                        </div>
                    `;
              }
              html += '</div>';

              // Link
              html += `
                <div style="margin-top:10px; text-align:center;">
                    <a href="${data.url}" target="_blank" style="color:#3498db; text-decoration:none; font-size:12px;">View Full Report â†—</a>
                </div>`;

              deckCheckResult.innerHTML = html;
              checkBtn.textContent = "âœ… Verified";

            } catch (e) {
              console.error("Verification Error:", e);
              let errorHtml = `<div style="color:#e74c3c">Verification Failed: ${e.message}</div>`;

              if (e.debugImage) {
                errorHtml += `<div style="margin-top:10px; border:1px solid #e74c3c; padding:5px; background:rgba(0,0,0,0.5);">
                   <div style="font-size:10px; color:#aaa; margin-bottom:5px;">Debug View (What the server saw):</div>
                   <img src="${e.debugImage}?t=${Date.now()}" style="width:100%; border-radius:4px;">
                 </div>`;
              }

              deckCheckResult.innerHTML = errorHtml + `<div style="margin-top:10px;"><a href="#" onclick="window.open('https://www.deckshop.pro','_blank')">Try Manual Check</a></div>`;
              checkBtn.textContent = "âŒ Retry Check";
            } finally {
              checkBtn.disabled = false;
            }
          };
        }

        // 5b. ROYALEAPI LINK GENERATOR





        // 4. STRATEGY GUIDE GENERATOR (ENHANCED: ~50 words per paragraph)
        function generateStrategyGuide(deck) {
          const guidePanel = document.getElementById('strategyGuide');
          const deckNames = deck.map(c => c.name);
          const winCon = deck.find(c => getCardRole(c.name).includes('winCon'));
          const winConName = winCon ? winCon.name : "your main troops";
          const building = deck.find(c => getCardRole(c.name).includes('building'));

          const heavySpell = deck.find(c => getCardRole(c.name).includes('spellBig'));
          const lightSpell = deck.find(c => getCardRole(c.name).includes('spellSmall'));

          const avgElixir = (deck.reduce((a, c) => a + (c.elixirCost || 0), 0) / 8).toFixed(1);
          const playstyle = avgElixir < 3.3 ? "Cycle" : avgElixir > 4.0 ? "Beatdown" : "Control";

          let html = `<h3>ðŸ§  AI Strategy Coach</h3>`;

          // P1: Gameplan (~50 words)
          let gp = [];
          gp.push(`<strong>Gameplan (${playstyle}):</strong> Your primary objective is to control the flow of the match by efficiently trading elixir and strategically setting up ${winConName} for a breakthrough.`);
          if (playstyle === 'Cycle') {
            gp.push(`Since your deck is extremely cheap (${avgElixir} average elixir), you must force your opponent to play at your speed by constantly applying pressure. Cycle your cheap cards rapidly to get back to ${winConName} before they have their counter ready, and relentlessly chip away at their tower health with each cycle. The key to success is maintaining unrelenting pressure while defending efficiently with minimal elixir investment.`);
          } else if (playstyle === 'Beatdown') {
            gp.push(`With a heavy average cost of ${avgElixir} elixir, patience must be utilized as your greatest weapon in this archetype. You must be willing to sacrifice some tower health in the early game to build a massive elixir advantage, then overwhelm them with an unstoppable push featuring ${winConName} during Double Elixir time. Focus on making small positive trades on defense, and never overcommit until you have the elixir to support your tank properly with multiple supporting units.`);
          } else {
            gp.push(`This Control deck relies on establishing a rock-solid defense that frustrates your opponent at every turn. Counter their pushes efficiently for positive elixir trades, then immediately transition that surviving defense into a deadly counter-attack with ${winConName} while they are low on elixir and vulnerable. Your goal is to outlast them through superior defensive play and punish every mistake they make with precise counter-pushes that capitalize on their elixir disadvantage.`);
          }
          html += `<p>${gp.join(' ')}</p>`;

          // P2: Starting Hand (~50 words)
          let sh = [];
          sh.push(`<strong>Starting Hand:</strong> The first minute sets the tempo for the entire match and reveals critical information about your opponent's deck.`);
          const cycles = deck.filter(c => (c.elixirCost || 0) <= 2 && c.name !== 'Zap' && c.name !== 'Log');
          if (cycles.length > 0) {
            sh.push(`Your optimal opening move is to play <strong>${cycles[0].name}</strong> either at the bridge to apply early pressure or split in the back to safely build elixir. This forces your opponent to react first and reveal their deck archetype without you committing significant elixir, allowing you to identify their win condition and save your hard counters for the perfect moment. Never leak elixir in the opening, and pay close attention to what cards they play.`);
          } else if (playstyle === 'Beatdown') {
            sh.push(`Do not be the first player to make a move unless you are at maximum elixir and about to leak. If your opponent also waits, play your cheapest supporting unit in the very back corner to safely bank elixir. Never drop your expensive Tank first in single elixir unless you want to be severely punished by an aggressive opposite-lane push that you cannot adequately defend. Patience wins games with heavy decks, so take your time and let the match develop naturally.`);
          } else {
            sh.push(`If you have a defensive Building in your starting hand, only place it reactively in the center if they rush the opposite lane aggressively. Otherwise, split Archers safely in the back or cycle a cheap Spirit at the bridge. Never reveal your ${winConName} first in the opening unless you are punishing a heavy elixir commitment they made in the back. The goal is to force them to show their hand while keeping yours hidden and flexible.`);
          }
          html += `<p>${sh.join(' ')}</p>`;

          // P3: Offense tips (~50 words)
          let off = [];
          off.push(`<strong>Offense:</strong>`);
          if (deckNames.includes('Miner') && deckNames.includes('Wall Breakers')) {
            off.push(`This is a high-skill tempo combo that can devastate unprepared opponents. Send the Miner to the tower first to tank defensive building and tower shots, then immediately drop Wall Breakers at the bridge so the Miner absorbs damage while the Wall Breakers connect. If your opponent panics and misplays their counter, they will lose half their tower in seconds. Master the timing between Miner deploy and Wall Breaker drop (approximately 1 second delay) for maximum effectiveness and tower damage.`);
          } else if (deckNames.includes('Hog Rider')) {
            off.push(`Hog Rider is aggressive and fast but is easily hard-countered by buildings and swarms if you are not prepared. You must carefully track their best counter card throughout the match (such as a Building, Tornado, or Skeleton Army). Pre-select your ${lightSpell ? lightSpell.name : 'spell'} immediately after deploying Hog Rider and be ready to fire it instantly the precise moment they drop their defensive counter. Prediction spells are extremely powerful if you can read their defensive patterns and anticipate their play.`);
          } else if (deckNames.includes('Golem') || deckNames.includes('Giant')) {
            off.push(`A lone Tank without support is easily killed and represents a massive wasted elixir investment. Always build a proper push by placing ${winConName} in the very back corner during single elixir, then methodically layer strong supporting troops like ${deck.find(c => c.elixirCost === 4)?.name || 'Musketeer'} directly behind it as you approach the bridge. These support units will protect your tank from swarms, air units, and Infernal buildings while also providing significant additional damage. Patience and proper push building are absolutely essential for beatdown success.`);
          } else {
            off.push(`Effective offense with ${winConName} requires excellent timing and game sense rather than mindless aggression. Wait patiently until you have either built a clear elixir advantage through efficient defense, or your opponent has just used their best counter card and cannot cycle back to it. Support your ${winConName} aggressively with spell support to eliminate their defensive answers and ensure tower connections. Every push should have a clear purpose and strategic reasoning behind it rather than random deployment.`);
          }
          html += `<p>${off.join(' ')}</p>`;

          // P4: Defense tips (~50 words)
          let def = [];
          def.push(`<strong>Defense:</strong>`);
          def.push(`A perfect defense always translates directly into a winning counter-attack offense, so treat every defensive sequence as an investment.`);
          if (heavySpell) def.push(`Hold your ${heavySpell.name} spell for extremely high-value targets like a Witch or Night Witch stacked directly behind a Giant push, or save it to finish off a low-health tower during overtime pressure. Do not waste this valuable spell on single low-value targets unless it is absolutely necessary for survival, as you will desperately need it later for game-winning moments. Spell discipline often determines match outcomes.`);
          if (building) def.push(`Your ${building.name} building is the anchor and foundation of your entire defensive strategy. Place it precisely 4 tiles from the river in the middle to pull tanks like Hog Rider or Giant into the center kill zone, allowing both of your Princess Towers to simultaneously target them for maximum damage output. Proper building placement is a fundamental skill that separates good players from great ones.`);
          def.push(`Learn to use your Tower's health as a strategic resource rather than something sacred to preserve. It is often better to take 500-700 damage and maintain an elixir advantage than to panic and spend 6 elixir desperately defending against a 3 elixir troop. Overcommitting on defense is one of the biggest mistakes players make, leading to devastating counter-pushes that you cannot stop.`);
          html += `<p>${def.join(' ')}</p>`;

          guidePanel.innerHTML = html;
          guidePanel.style.display = 'block';
        }

        // 2. Scoring Algorithm (GOD MODE - STRICT TEMPLATE)
        // Template: 1 WinCon, 1 MiniTank, 1 Swarm, 2 AirDef, 1 SmallSpell, 1 BigSpell, 1 Flex
        function scoreCard(card) {
          const cardRoles = getCardRole(card.name);
          const roles = getDeckRoles(builderDeck); // Current state

          let score = (Math.random() * 100) - 50; // GOD MODE: Minimal Jitter (+/- 50)

          // -------------------------------------------------------------
          // 0. EVOLUTION & CHAMPION PRIORITY (GENIUS MODE)
          // -------------------------------------------------------------
          if ((card.evolutionLevel || 0) > 0) {
            score += 3000; // MASSIVE BONUS: Always pick owned Evolutions
          }
          if (card.rarity === 'champion') {
            score += 1000; // Priority for Champions
          }

          // -------------------------------------------------------------
          // 1. STRICT ROLE TEMPLATE ENFORCEMENT
          // -------------------------------------------------------------

          // A. WIN CONDITION (Limit: 1)
          if (cardRoles.includes('winCon')) {
            if (roles.hasWinCon) {
              // EXCEPTION: Secondary WinCons allowed in Flex spot if explicit synergy
              const allowDouble = (card.name === 'Miner' && builderDeck.some(c => c.name === 'Wall Breakers')) ||
                (card.name === 'Wall Breakers' && builderDeck.some(c => c.name === 'Miner')) ||
                (card.name === 'Balloon' && builderDeck.some(c => c.name === 'Lava Hound')) ||
                (card.name === 'Skeleton Barrel' && builderDeck.some(c => c.name === 'Mega Knight'));

              if (!allowDouble) score -= 10000; // HARD BAN on 2nd WinCon
              else score += 500;
            } else {
              // WE NEED A WIN CON
              score += 2000;
              // Boost for proprietary "Best" WinCons if undefined style
              if (['Hog Rider', 'Miner', 'Graveyard', 'Goblin Drill', 'Golem'].includes(card.name)) score += 500;
            }
          }

          // B. SMALL SPELL (Limit: 1)
          if (cardRoles.includes('spellSmall')) {
            if (roles.hasSmallSpell) score -= 5000; // Hard limit
            else {
              score += 1500; // High priority
              if (roles.hasBigSpell) score += 500; // Complete the spell pair
            }
          }

          // C. BIG SPELL (Limit: 1)
          if (cardRoles.includes('spellBig')) {
            if (roles.hasBigSpell) score -= 5000;
            else {
              score += 1500;
              if (roles.hasSmallSpell) score += 500;
            }
          }

          // D. MINI TANK (Limit: 1... maybe 2 for bridge spam)
          // We count strictly mini tanks (Knight, valk, etc)
          const miniTankCount = builderDeck.filter(c => getCardRole(c.name).includes('miniTank')).length;
          if (cardRoles.includes('miniTank')) {
            if (miniTankCount >= 2) score -= 5000; // Hard Cap at 2
            else if (miniTankCount === 1) score -= 500; // Soft Cap at 1 (Prefer Air/Swarm/Flex)
            else score += 1200; // NEED ONE
          }

          // E. AIR DEFENSE (Minimum: 2)
          // We count specific strong air counters
          const airCount = builderDeck.filter(c => getCardRole(c.name).includes('airCounter')).length;
          if (cardRoles.includes('airCounter')) {
            if (airCount < 2) score += 2500; // CRITICAL PRIORITY
            else score += 200; // Good to have more, but not critical
          }

          // F. SWARM / CYCLE / UTILITY
          // If we have WinCon + Spells + Tank + Air, we need cheap defense or swarms
          // Logic implicitly handled by "What's left" and Synergies, but let's boost Swarms if missing
          const swarmCount = builderDeck.filter(c => ['Goblin Gang', 'Skeletons', 'Bats', 'Goblins', 'Spear Goblins', 'Guards', 'Skarmy'].includes(c.name)).length;
          if (swarmCount === 0 && (card.elixirCost || 0) <= 3) {
            // General boost for cheap cards if no swarms
            score += 400;
          }

          // -------------------------------------------------------------
          // 2. LEVEL & META LOGIC
          // -------------------------------------------------------------

          // Factor 0.5: Meta Quality
          if (META_QUALITY[card.name]) score += (META_QUALITY[card.name] * 0.8);

          // Factor 1: Level Logic (STRICTER)
          let normLevel = normalizeLevel(card);
          score += (normLevel * 100);

          const levelGap = playerPeakLevel - normLevel;
          // STRICTER LEVEL PENALTY (User Request: "Keep levels in consideration")
          if (levelGap <= 0) score += 1000; // BEST CARDS (Peak Level)
          else if (levelGap === 1) score += 100; // 1 Level under is fine
          else if (levelGap >= 2) score -= 5000; // SIGNIFICANT PENALTY for 2 levels under
          else if (levelGap >= 3) score -= 20000; // NUCLEAR BAN for 3+ levels under (Unplayable)

          // -------------------------------------------------------------
          // 3. SYNERGY & ARCHETYPES
          // -------------------------------------------------------------

          // Playstyle Bonus
          if (selectedPlaystyle !== 'any') {
            // ... existing playstyle logic is fine, but role template overrides it mostly
            // we can give a small nudge
            // (Copying simplified logic to avoid huge block)
            const isSynergistic = SYNERGIES.some(pair => pair.includes(card.name) && builderDeck.some(d => pair.includes(d.name)));
            if (isSynergistic) score += 400;
          }

          // Anti-Repetition
          if (!getCardRole(card.name).includes('winCon')) { // allow win cons to repeat if user really wants that style
            if (previousDeckNames.has(card.name)) score -= 10000; // ROTATION
          }

          // Elixir Management (Prevent > 4.0 avg)
          const currentCost = builderDeck.reduce((a, c) => a + (c.elixirCost || 0), 0);
          const projectedAvg = (currentCost + (card.elixirCost || 0)) / (builderDeck.length + 1);
          if (builderDeck.length > 4 && projectedAvg > 4.1) score -= 1000;

          return score;
        }

        // Get available cards
        // Filter out champions if one already exists
        const hasChampion = builderDeck.find(c => c.rarity === 'Champion' || c.rarity === 'champion');
        const deckNames = new Set(builderDeck.map(c => c.name)); // Convert to Set for efficient lookup
        const all = currentPlayerData.cards; // Assuming all available cards are in currentPlayerData.cards

        // Filter available
        let available = all.filter(c => {
          if (deckNames.has(c.name)) return false;
          if (excludedCards.has(c.name)) return false; // NEW: Exclude banned cards
          if (c.rarity === 'Champion' && hasChampion) return false;
          return true;
        });

        console.log(`DEBUG POOL SIZE: ${available.length} cards available for selection.`);
        if (available.length < 10) console.warn("WARNING: Very small card pool!");

        // 0. FORCED PLAYSTYLE START (The "Captain" Rule)
        // If user explicitly chose a style, we MUST start with that style's key card.
        // Otherwise the "Strict Win Con" rule might pick a different win con first and block this one.
        if (selectedPlaystyle !== 'any') {
          const captains = {
            'miner': ['Miner', 'Mighty Miner'],
            'hog': ['Hog Rider', 'Ram Rider'], // 'cycle' often means hog
            'cycle': ['Hog Rider', 'Royal Hogs'],
            'beatdown': ['Golem', 'Electro Giant', 'Lava Hound', 'Giant', 'Goblin Giant'],
            'siege': ['X-Bow', 'Mortar'],
            'bait': ['Goblin Barrel', 'Princess'],
            'bridgespam': ['Battle Ram', 'P.E.K.K.A', 'Ram Rider'],
            'graveyard': ['Graveyard'],
            'control': ['Graveyard', 'Miner', 'Poison']
          };

          const targetCaptains = captains[selectedPlaystyle];
          if (targetCaptains) {
            // Find the best available captain (owned by player)
            // Sort by Level to pick the best one
            const myCaptains = available.filter(c => targetCaptains.includes(c.name));
            myCaptains.sort((a, b) => normalizeLevel(b) - normalizeLevel(a));

            if (myCaptains.length > 0) {
              const captain = myCaptains[0];
              console.log("Force-Adding Captain for " + selectedPlaystyle, captain.name);
              builderDeck.push(captain);
              deckNames.add(captain.name); // update lookup set
              available = available.filter(c => c.name !== captain.name);
              renderBuilderUI();
              await new Promise(r => setTimeout(r, 200));
            }
          }
        }

        // Loop to fill
        for (let i = 0; i < slotsToFill; i++) {
          if (available.length === 0) break;

          let best = null;
          let maxScore = Number.NEGATIVE_INFINITY;

          // Safe Scoring Loop
          for (const card of available) {

            // STRICT WIN CONDITION LIMIT
            // If we already have a Win Condition, DO NOT pick another one (unless it's a specific synergy)
            const currentWinCon = builderDeck.find(c => getCardRole(c.name).includes('winCon'));
            if (currentWinCon) {
              const candidateRole = getCardRole(card.name);
              if (candidateRole.includes('winCon')) {
                // ALLOW EXCEPTIONS: Miner + Wall Breakers, or Balloon + Lava Hound
                const isMinerWB = (currentWinCon.name === 'Miner' && card.name === 'Wall Breakers') || (currentWinCon.name === 'Wall Breakers' && card.name === 'Miner');
                const isLavaLoon = (currentWinCon.name === 'Lava Hound' && card.name === 'Balloon') || (currentWinCon.name === 'Balloon' && card.name === 'Lava Hound');
                const isGiantSparky = (currentWinCon.name === 'Goblin Giant' && card.name === 'Sparky') || (currentWinCon.name === 'Sparky' && card.name === 'Goblin Giant');

                if (!isMinerWB && !isLavaLoon && !isGiantSparky) {
                  continue; // SKIP this card entirely
                }
              }
            }

            // STRICT SPELL LIMIT (Max 2 Spells)
            // No more 3-spell decks.
            const currentSpells = builderDeck.filter(c => getCardRole(c.name).includes('spellBig') || getCardRole(c.name).includes('spellSmall')).length;
            const isCandidateSpell = getCardRole(card.name).includes('spellBig') || getCardRole(card.name).includes('spellSmall');
            if (currentSpells >= 2 && isCandidateSpell) {
              continue; // SKIP spell
            }

            // STRICT MINI TANK / BRUISER LIMIT (Max 2)
            // Broader definition: MiniTanks + TankKillers like Pekka + Mega Knight
            const getTankiness = (name) => {
              const r = getCardRole(name);
              if (r.includes('miniTank')) return true;
              if (['Mega Knight', 'P.E.K.K.A', 'Giant Skeleton', 'Bowler'].includes(name)) return true;
              return false;
            };

            const currentMiniTanks = builderDeck.filter(c => getTankiness(c.name)).length;
            const isCandidateMiniTank = getTankiness(card.name);

            if (isCandidateMiniTank) {
              // HARD STOP: If we already have 2, DO NOT add a 3rd.
              if (currentMiniTanks >= 2) {
                continue;
              }
              // SOFT LIMIT: If we have 1, penalize the 2nd heavily unless it really fits
              if (currentMiniTanks === 1) {
                // Only allow if it's a Bridge Spam archetype or specific dual-lane pressure
                // Otherwise, penalize to prefer other support cards
                // score -= 500; // This will be applied later in the scoring logic, but we can skip early if needed.
                // Let's rely on scoring, but the Hard Stop above guarantees no 3rd.
              }
            }

            if (builderDeck.length >= 6) {
              const airCounters = builderDeck.filter(c => getCardRole(c.name).includes('airCounter')).length;
              if (airCounters < 2) {
                // Start rejecting non-air-counters until we satisfy the condition
                if (!getCardRole(card.name).includes('airCounter')) {
                  // Soft rejection: massively penalize non-air cards instead of hard skipping?
                  // Actually, hard skip is safer to guarantee it happens.
                  continue;
                }
              }
            }

            // USER FEEDBACK: MINER DECKS PREFER 1 CYCLE CARD (BUT 2 IS OK)
            // Soft Limit: If we have Miner and 1 cycle card already, PENALIZE the next one but allow it if it's really good.
            const hasMiner = builderDeck.some(c => c.name === 'Miner');
            if (hasMiner) {
              const isCycleTroop = (c) => (c.elixirCost || 0) <= 2 && !getCardRole(c.name).includes('spell');
              // Count current cycle troops
              const currentCycleTroops = builderDeck.filter(isCycleTroop).length;

              // Check candidate
              if (isCycleTroop(card) && currentCycleTroops >= 1) {
                // Apply penalty instead of skip
                // Score is usually around 100-300 range.
                // -200 should be enough to make it lose to a good Musketeer/Knight unless it's godly.
                // If we have 2 already, strictly block 3rd.
                if (currentCycleTroops >= 2) continue;

                // Penalty for 2nd cycle card
                // We'll modify the score inside the try/catch loop next to be safe, 
                // OR just soft-skip here? 
                // We can't easily modify score BEFORE the scoreCard function runs.
                // So let's wrap the scoreCard call below.
              }
            }

            let score = 0;
            try {
              score = scoreCard(card);

              // Apply Penalty for 2nd Cycle Card in Miner Decks
              if (hasMiner) {
                const isCycleTroop = (cName, cCost) => (cCost || 0) <= 2 && !getCardRole(cName).includes('spell');
                const currentCycleTroops = builderDeck.filter(c => isCycleTroop(c.name, c.elixirCost)).length;

                if (currentCycleTroops >= 1 && isCycleTroop(card.name, card.elixirCost)) {
                  console.log(`Soft limiting 2nd cycle card: ${card.name}`);
                  score -= 250; // Significant penalty, but allows it if other synergies are huge (+1000)
                }
              }
            } catch (err) {
              console.error("Score Error", card.name, err);
              score = -1000;
            }

            if (score > maxScore) {
              maxScore = score;
              best = card;
            }
          }

          if (best) {
            // STRICT DUPLICATE CHECK
            if (builderDeck.some(c => c.name === best.name)) {
              console.warn("Attempted to add duplicate:", best.name);
            } else {
              builderDeck.push(best);
            }
            try {
              // Update UI incrementally, but don't crash if it fails
              renderBuilderUI();
              updateStats();
            } catch (e) { console.log('UI Update error', e); }
          } else {
            console.warn("No best card found. Available:", available.length);
            break;
          }

          // Remove from pool
          available = available.filter(c => c.name !== best.name);

          // Card Add Delay
          await new Promise(r => setTimeout(r, 400));
        }

        // 3. Update History for Next Rotation
        console.log("Deck Generation Complete. Updating History...");
        builderDeck.forEach(c => previousDeckNames.add(c.name));
        console.log("Blocked Cards for Next Run:", Array.from(previousDeckNames));

        aiStatus.textContent = 'Deck Generation Complete!';
        autofillBtn.textContent = originalText;
        autofillBtn.disabled = false;
        autofillBtn.style.background = ''; // Reset color

        // --- Post-Processing: Slot Assignment ---
        // Rule: Slot 1 (Index 0) and Slot 2 (Index 1) = Evolution Slots
        // Champions often last.

        // 1. Gather all candidates that the player ACTUALLY has evolved
        // STRICT CHECK: evolutionLevel must be > 0. Merely having an image isn't enough.
        const evoCandidates = builderDeck.filter(c => (c.evolutionLevel || 0) > 0);

        // Sort by level (highest first), then by arbitrary 'tier' preference if levels equal?
        // For now, Levels are king.
        evoCandidates.sort((a, b) => (b.level || 0) - (a.level || 0));

        // 2. Take top 2 available owned evos
        const topEvos = evoCandidates.slice(0, 2);

        // 3. Move them to front (Slot 0, Slot 1)
        for (const evo of topEvos) {
          const idx = builderDeck.indexOf(evo);
          if (idx > -1) {
            builderDeck.splice(idx, 1);
            builderDeck.unshift(evo);
          }
        }

        renderBuilderUI();

        // SAVE CURRENT DECK TO PREVIOUS DECK LIST
        previousDeckNames.clear();
        builderDeck.forEach(c => previousDeckNames.add(c.name));
        console.log("Next Run Banned List:", Array.from(previousDeckNames));

        updateStats();
        generateStrategyGuide(builderDeck);

        // 5. AUTO-VERIFY WITH DECKSHOP (Moved to end)
        if (builderDeck.length === 8) {
          (async () => {
            // START NEW SESSION
            if (typeof verifySessionId !== 'undefined') verifySessionId++;
            const currentSession = typeof verifySessionId !== 'undefined' ? verifySessionId : 0;

            const checkResult = document.getElementById('deckCheckResult'); // Correct ID
            if (!checkResult) return;
            checkResult.style.display = 'block';
            checkResult.innerHTML = '<div style="color:#f1c40f; text-align:center;">Verifying with DeckShop...</div>';

            try {
              const names = builderDeck.map(c => c.name);
              const res = await fetch(`/api/check-deck?t=${Date.now()}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ deck: names })
              });

              if (typeof verifySessionId !== 'undefined' && currentSession !== verifySessionId) return; // Stale

              if (!res.ok) throw new Error("Server error");
              const data = await res.json();

              if (typeof verifySessionId !== 'undefined' && currentSession !== verifySessionId) return; // Stale

              if (data.evaluation) {
                let html = `<div style="text-align:center; margin-bottom:15px; font-weight:bold; color:#f1c40f; letter-spacing:1px;">VERIFIED WITH DECKSHOP.PRO</div>`;
                html += `<div class="deck-grade-grid">`;
                for (const [key, val] of Object.entries(data.evaluation)) {
                  let color = '#95a5a6';
                  let cleanVal = val.replace('Of', '');
                  if (val.includes('Godly')) color = '#e74c3c';
                  else if (val.includes('Great') || val.includes('Good')) color = '#2ecc71';
                  else if (val.includes('Mediocre')) color = '#f1c40f';
                  else if (val.includes('Bad')) color = '#7f8c8d';

                  html += `
                      <div class="grade-box">
                          <div class="grade-label">${key}</div>
                          <div class="grade-val" style="color:${color}">${cleanVal}</div>
                      </div>`;
                }
                html += `</div>`;
                // NEW: Open Report Explicitly Button (Prevents auto-tab unwanted behavior)
                html += `<div style="margin-top:20px; text-align:center;">
                    <a href="${data.url}" target="_blank" class="action-btn" style="background:#2980b9; color:white; text-decoration:none; display:inline-block; padding:8px 16px; border-radius:4px;">
                      ðŸ“„ Open Full Report (External)
                    </a>
                    <div style="font-size:10px; color:#aaa; margin-top:5px;">Opens validation on DeckShop.pro</div>
                </div>`;
                checkResult.innerHTML = html;
              }
            } catch (e) {
              if (typeof verifySessionId !== 'undefined' && currentSession !== verifySessionId) return;
              console.error("Auto-verify failed", e);
              checkResult.innerHTML = `<div style="color:#e74c3c; text-align:center;">Verification failed: ${e.message}</div>`;
            }
          })();
        }

        const autoBtn = document.getElementById('autofillBtn');
        autoBtn.disabled = false;
        autoBtn.textContent = "âœ¨ Regenerate (Force New Cards)"; // Change text

        document.getElementById('aiStatus').textContent = `Generation Complete!`;
        aiStatus.textContent = 'Deck Generation Complete.';
        autofillBtn.disabled = false;
        autofillBtn.textContent = originalText;
        autofillBtn.style.background = '#8e44ad';
      }




      // ENSURE IMPROVE BTN LOGIC IS ATTACHED SAFELY
      // This wrapper ensures we override any previous listeners that might trigger "Weakness Check"
      /* attachImproveLogic Removed */
      const createNewBtn = document.getElementById('createNewBtn');

      // Shared Helper to prepare Builder Mode
      const ensureBuilderMode = () => {
        if (!currentPlayerData) {
          alert('Scan a player first!');
          return false;
        }
        if (!isBuilderMode) toggleBuilderMode();

        // Clear verification results
        const deckCheckResult = document.getElementById('deckCheckResult');
        if (deckCheckResult) {
          deckCheckResult.style.display = 'none';
          deckCheckResult.innerHTML = '';
        }
        return true;
      };

      // 1. CREATE NEW LOGIC (Full Rebuild)
      if (createNewBtn) {
        createNewBtn.addEventListener('click', () => {
          if (!ensureBuilderMode()) return;

          console.log("Create New: Wiping deck...");
          // Save history
          previousDeckNames.clear();
          builderDeck.forEach(c => previousDeckNames.add(c.name));

          builderDeck = []; // Wipe completely
          renderBuilderUI();
          aiStatus.textContent = 'Creating New Deck...';

          // Small delay for UI update
          setTimeout(() => runExpertAutofill(), 500);
        });
      }


      // SUBSTITUTIONS LOGIC
      const subBtn = document.getElementById('substitutionsBtn');
      const subModal = document.getElementById('substitutionsModal');
      const subGrid = document.getElementById('subsGrid');
      const subSearch = document.getElementById('subSearch');

      if (subBtn) {
        // Show button when improve is shown (or whenever we have a deck)
        // Ideally trigger this inside runImproveLogic, but we can just unhide it here if deck exists
        // Observer removed (improveBtn deleted)

        subBtn.onclick = () => {
          if (!currentPlayerData) {
            alert("Scan player first!");
            return;
          }

          // FIX: Populate builderDeck if empty (e.g. fresh scan)
          if (builderDeck.length === 0) {
            console.log("Substitutions: builderDeck empty. Attempting recovery...");

            // Attempt 1: From currentAppDeck (Set by renderDeck - Most Reliable)
            if (window.currentAppDeck && window.currentAppDeck.length > 0) {
              console.log("Substitutions: Recovering from currentAppDeck");
              builderDeck = [...window.currentAppDeck];
            }
            // Attempt 2: From currentPlayerData
            else {
              const scannedDeck = extractCards(currentPlayerData);
              if (scannedDeck.length > 0) {
                console.log("Substitutions: Recovering from extractCards");
                builderDeck = [...scannedDeck];
              }
              // Attempt 3: From DOM (Robust Fallback)
              else if (document.querySelectorAll('#deckContainer .card-item').length > 0) {
                console.log('Substitutions: Scraping deck from DOM before open...');
                const cardItems = document.querySelectorAll('#deckContainer .card-item');
                const scrapedDeck = [];
                cardItems.forEach(el => {
                  const nameEl = el.querySelector('.card-name');
                  const name = nameEl ? nameEl.textContent : (el.querySelector('img')?.alt || "");
                  if (name) {
                    let fullCard = null;
                    if (currentPlayerData && currentPlayerData.cards) {
                      fullCard = currentPlayerData.cards.find(c => c.name === name);
                    }
                    if (!fullCard) {
                      fullCard = {
                        name: name,
                        elixirCost: 3,
                        iconUrls: { medium: el.querySelector('img')?.src || '' }
                      };
                    }
                    scrapedDeck.push(fullCard);
                  }
                });
                if (scrapedDeck.length > 0) builderDeck = scrapedDeck;
              }
            }

            if (builderDeck.length > 0) {
              console.log("Substitutions: Deck successfully populated. Length:", builderDeck.length);
              renderBuilderUI();
            } else {
              console.error("Substitutions: Critical Error - Could not populate builderDeck");
              alert("Error: Could not read deck. Please try scanning the player again.");
            }
          }

          subModal.style.display = 'flex';
          renderSubPicker();
        };

        subSearch.addEventListener('input', (e) => {
          renderSubPicker(e.target.value);
        });
      }

      const smartRefreshBtn = document.getElementById('smartRefreshBtn');
      if (smartRefreshBtn) {
        // Updated Observer to ensure it stays visible if needed, but we also manually show it in renderPlayer
        // Observer removed (improveBtn deleted)

        smartRefreshBtn.onclick = async () => {
          // Feature: Support running on current deck if builderDeck is empty
          if (builderDeck.length === 0 && currentPlayerData) {
            const deck = extractCards(currentPlayerData);
            if (deck.length > 0) {
              builderDeck = [...deck];
              // Switch to builder mode visually so the transition makes sense
              if (!isBuilderMode) {
                toggleBuilderMode();
              }
              renderBuilderUI();
            }
          }

          if (builderDeck.length === 0) { alert("Deck is empty!"); return; }

          // 1. Score all cards to find the "Core"
          const scored = builderDeck.map(c => {
            let s = META_QUALITY[c.name] || 50;
            const role = getCardRole(c.name);
            // PRIORITIZE CORE: WinCon (+50), Champion (+40), Evolution (+30)
            if (role.includes('winCon')) s += 50;
            if (c.rarity === 'champion') s += 40;
            if ((c.evolutionLevel || 0) > 0) s += 30;
            // Penalty for tiny spells (usually replaceable)
            if (role.includes('spellSmall')) s -= 10;

            return { card: c, score: s };
          });

          // 2. Sort DESC
          scored.sort((a, b) => b.score - a.score);

          // 3. Keep Top 4 (Smart Filter)
          const kept = [];
          let counts = { miniTank: 0, winCon: 0, building: 0 };

          for (const item of scored) {
            if (kept.length >= 4) break;
            const c = item.card;
            const roles = getCardRole(c.name);

            // Enforce Diversity in the Core
            let skip = false;

            if (roles.includes('miniTank')) {
              if (counts.miniTank >= 1) skip = true; // Only keep 1 Core Mini Tank
            }
            if (roles.includes('winCon')) {
              // Exception: Miner + Wall Breakers allows 2
              if (counts.winCon >= 1) skip = true;
            }
            if (roles.includes('building')) {
              if (counts.building >= 1) skip = true;
            }

            if (!skip) {
              kept.push(c);
              if (roles.includes('miniTank')) counts.miniTank++;
              if (roles.includes('winCon')) counts.winCon++;
              if (roles.includes('building')) counts.building++;
            }
          }

          // Fallback: If aggressive filtering resulted in < 4 cards, fill with next best regardless (safety net)
          if (kept.length < 4) {
            for (const item of scored) {
              if (kept.length >= 4) break;
              if (!kept.some(k => k.name === item.card.name)) {
                kept.push(item.card);
              }
            }
          }

          // 4. Update Deck
          builderDeck = kept;
          renderBuilderUI();

          // 5. Fill the rest
          const originalText = smartRefreshBtn.textContent;
          smartRefreshBtn.textContent = "Refilling...";
          smartRefreshBtn.disabled = true;

          // Trigger Autofill
          try {
            await runExpertAutofill();
          } catch (e) {
            console.error("Smart Refresh Error:", e);
            alert("Error refilling deck. See console.");
          }

          smartRefreshBtn.textContent = originalText;
          smartRefreshBtn.disabled = false;
        };
      }

      function renderSubPicker(filter = '') {
        subGrid.innerHTML = '';
        // Fix: Add spacing via inline style if class fails
        subGrid.style.display = 'grid';
        subGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(80px, 1fr))';
        subGrid.style.gap = '15px';
        subGrid.style.padding = '10px';

        // Get cards NOT in deck
        const currentNames = builderDeck.map(c => c.name.trim());
        // Debug:
        console.log("Current Deck for Substitutions:", currentNames);

        // FIX: PREFER FULL COLLECTION (data.cards) OVER extractCards(which privileges currentDeck)
        let sourceCards = [];
        if (currentPlayerData && Array.isArray(currentPlayerData.cards)) {
          sourceCards = currentPlayerData.cards;
        } else {
          sourceCards = extractCards(currentPlayerData);
        }

        let pool = sourceCards.filter(c => !currentNames.includes(c.name.trim()));

        if (filter) {
          const lower = filter.toLowerCase();
          pool = pool.filter(c => c.name.toLowerCase().includes(lower));
        }

        // Sort by Level (Desc) then Rarity
        pool.sort((a, b) => normalizeLevel(b) - normalizeLevel(a));

        if (pool.length === 0) {
          subGrid.innerHTML = '<p style="color:#aaa; text-align:center;">No cards found.</p>';
          return;
        }

        pool.forEach(card => {
          // FIX: Inline card creation with EXPLICIT CLICKABILITY STYLES
          const wrapper = document.createElement('div');
          wrapper.style.position = 'relative';
          wrapper.style.display = 'inline-block';
          wrapper.style.cursor = 'pointer';
          wrapper.style.transform = 'scale(0.95)';
          wrapper.style.zIndex = '2002'; // Force on top of modal
          wrapper.style.pointerEvents = 'auto'; // Force click capture
          wrapper.style.margin = '6px';
          wrapper.style.border = '2px solid transparent';
          wrapper.style.borderRadius = '8px';
          wrapper.style.transition = 'all 0.2s';

          // Hover effect for visual confirmation
          wrapper.onmouseenter = () => {
            wrapper.style.borderColor = '#ffd700';
            wrapper.style.transform = 'scale(1.05)';
            wrapper.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.4)';
          };
          wrapper.onmouseleave = () => {
            wrapper.style.borderColor = 'transparent';
            wrapper.style.transform = 'scale(0.95)';
            wrapper.style.boxShadow = 'none';
          };

          // Image
          const img = document.createElement('img');
          img.src = card.iconUrls?.medium || card.iconUrls; // Handle both formats
          img.className = 'picker-card';
          img.style.width = '85px'; // Slightly larger for easier clicking
          img.style.display = 'block';
          img.style.pointerEvents = 'none'; // FIX: Ensure clicks pass to wrapper

          // Click Handler on Wrapper to be safe
          wrapper.onclick = (e) => {
            e.stopPropagation();
            e.preventDefault(); // Stop any weird default behavior
            console.log("Substitution Clicked:", card.name);
            try {
              suggestRemoval(card);
            } catch (err) {
              console.error("Critical Click Error:", err);
              alert("Error: " + err.message);
            }
          };

          // Level Badge
          const badge = document.createElement('div');
          badge.textContent = normalizeLevel(card);
          badge.style.position = 'absolute';
          badge.style.bottom = '2px';
          badge.style.right = '2px';
          badge.style.background = 'rgba(0,0,0,0.8)';
          badge.style.color = '#f1c40f';
          badge.style.fontSize = '10px';
          badge.style.padding = '1px 3px';
          badge.style.borderRadius = '4px';
          badge.style.pointerEvents = 'none'; // FIX: Ensure clicks pass to wrapper

          wrapper.appendChild(img);
          wrapper.appendChild(badge);
          subGrid.appendChild(wrapper);
        });

      }

      function suggestRemoval(newCard) {
        try {
          // AI LOGIC: Find best candidate to remove
          // 1. Check Role Conflicts (Win Con for Win Con, Spell for Spell)
          // 2. Check Elixir Cost (keep average similar)
          // 3. Check Meta Quality (remove lowest quality)

          // FIX: Robustly ensure builderDeck is populated
          if (!builderDeck || builderDeck.length === 0) {
            // Attempt 1: Use window.currentAppDeck (set by renderDeck)
            if (window.currentAppDeck && window.currentAppDeck.length > 0) {
              console.log("SuggestRemoval: Recovering deck from currentAppDeck...");
              builderDeck = [...window.currentAppDeck];
              renderBuilderUI();
            }
            // Attempt 2: Use currentPlayerData.currentDeck
            else if (currentPlayerData && currentPlayerData.currentDeck && currentPlayerData.currentDeck.length > 0) {
              console.log("SuggestRemoval: Recovering deck from player profile...");
              builderDeck = [...currentPlayerData.currentDeck];
              renderBuilderUI();
            }
            // Attempt 3: SCRAPE FROM DOM (Last Resort) - NOTE: Might be empty if modal is open unique-view
            else {
              console.log("SuggestRemoval: Global state empty. DOM scraping might fail here if modal is open.");
              const cardItems = document.querySelectorAll('#deckContainer .card-item'); // Assuming .card-item class from deck render
              if (cardItems.length > 0) {
                const scrapedDeck = [];
                cardItems.forEach(el => {
                  const nameEl = el.querySelector('.card-name'); // Assuming renderDeck creates this
                  // Or try the title attribute/img alt
                  let name = "";
                  if (nameEl) name = nameEl.textContent;
                  else {
                    const img = el.querySelector('img');
                    if (img) name = img.alt;
                  }

                  if (name) {
                    // Create a skeletal card object
                    // Try to find full data from cards collection if possible
                    let fullCard = null;
                    if (currentPlayerData && currentPlayerData.cards) {
                      fullCard = currentPlayerData.cards.find(c => c.name === name);
                    }
                    if (!fullCard) {
                      // Fallback skeleton
                      fullCard = {
                        name: name,
                        elixirCost: 3, // Default dummy
                        iconUrls: { medium: el.querySelector('img')?.src || '' }
                      };
                    }
                    scrapedDeck.push(fullCard);
                  }
                });

                if (scrapedDeck.length > 0) {
                  builderDeck = scrapedDeck;
                  renderBuilderUI(); // Should now be populated
                }
              }
            }
          }

          if (!builderDeck || builderDeck.length === 0) {
            alert("Your deck is empty! Just adding the card.");
            builderDeck.push(newCard);
            renderBuilderUI();
            subModal.style.display = 'none';
            return;
          }

          const newRole = getCardRole(newCard.name);
          let bestRemove = null;
          let highestScore = -Infinity;

          builderDeck.forEach(existing => {
            let score = 0;
            const existingRole = getCardRole(existing.name);

            // 1. ROLE MATCHING (High Priority)
            if (newRole.includes('winCon') && existingRole.includes('winCon')) score += 50;
            if (newRole.includes('spellBig') && existingRole.includes('spellBig')) score += 50;
            if (newRole.includes('spellSmall') && existingRole.includes('spellSmall')) score += 40;
            if (newRole.includes('building') && existingRole.includes('building')) score += 30;
            if (newRole.includes('miniTank') && existingRole.includes('miniTank')) score += 35; // Added Mini Tank logic

            // 2. COST SIMILARITY
            const costDiff = Math.abs((newCard.elixirCost || 3) - (existing.elixirCost || 3));
            if (costDiff === 0) score += 20;
            if (costDiff === 1) score += 10;

            // 3. META TIER (Remove bad cards)
            // If existing card is low tier, we prefer removing it
            const quality = META_QUALITY[existing.name] || 50;
            score -= (quality * 0.2); // Higher quality = lower score to remove

            if (score > highestScore) {
              highestScore = score;
              bestRemove = existing;
            }
          });

          // Confirm Swap
          if (bestRemove) {
            const reason = getSwapReason(newCard, bestRemove);
            if (confirm(`To add ${newCard.name}, the AI suggests removing ${bestRemove.name}.\n\nReason: ${reason}\n\nProceed?`)) {
              // Apply Swap
              builderDeck = builderDeck.filter(c => c.name !== bestRemove.name);
              builderDeck.push(newCard);
              renderBuilderUI();
              updateStats(); // Update stats immediately
              subModal.style.display = 'none';

              // Trigger auto-verify update
              setTimeout(() => {
                const deckCheckResult = document.getElementById('deckCheckResult');
                if (deckCheckResult) deckCheckResult.style.display = 'none'; // reset previous check
              }, 100);
            }
          } else {
            alert("Could not determine a good swap. Deck might be full or inconsistent.");
          }
        } catch (err) {
          console.error("Error in suggestRemoval:", err);
          alert("An error occurred while suggesting a swap. Check console for details.");
        }
      }

      function getSwapReason(newC, oldC) {
        const newR = getCardRole(newC.name);
        const oldR = getCardRole(oldC.name); // FIXED: Was using undefined 'oldR' in previous thought? No, logic was just using 'spell' generic

        if (newR.includes('winCon') && oldR.includes('winCon')) return "Swapping Win Conditions to maintain deck structure.";
        if ((newR.includes('spellBig') || newR.includes('spellSmall')) && (oldR.includes('spellBig') || oldR.includes('spellSmall'))) return "Swapping Spells to balance splash/damage.";
        if (newR.includes('miniTank') && oldR.includes('miniTank')) return "Swapping Mini Tanks to maintain defense.";
        if (newR.includes('building') && oldR.includes('building')) return "Swapping Buildings.";

        if (Math.abs((newC.elixirCost || 0) - (oldC.elixirCost || 0)) <= 1) return `Similar elixir cost (${oldC.elixirCost || '?'} vs ${newC.elixirCost || '?'}) to maintain cycle.`;
        return "This balances your deck's stats and card roles.";
      }



      // REGENERATE BUTTON HANDLER (Fix for "Same Cards" bug)
      // The button needs to CLEAR the deck (keeping the Captain) before autofilling.
      const autoBtn = document.getElementById('autofillBtn');
      if (autoBtn) {
        autoBtn.addEventListener('click', () => {
          // If deck is full, we are in "Regenerate" mode
          if (builderDeck.length >= 8) {
            console.log("REGENERATE MODE: Clearing deck for variety...");

            // CRITICAL FIX: Snapshot current deck to force variety!
            previousDeckNames.clear();
            builderDeck.forEach(c => previousDeckNames.add(c.name));
            console.log("Banishing Current Cards:", Array.from(previousDeckNames));

            // 0. FORCED PLAYSTYLE START (The "Captain" Rule)
            // CRITICAL FIX: Only force the MAIN CAPTAIN (Win Condition), not the entire support crew.
            // Previously, this loop was forced-adding "Knight", "Poison", etc. bypassing the variety logic.

            let captainName = null;
            if (selectedPlaystyle === 'miner') captainName = 'Miner';
            else if (selectedPlaystyle === 'hog') captainName = 'Hog Rider';
            else if (selectedPlaystyle === 'graveyard') captainName = 'Graveyard';
            else if (selectedPlaystyle === 'golem') captainName = 'Golem';
            else if (selectedPlaystyle === 'lava') captainName = 'Lava Hound';
            else if (selectedPlaystyle === 'xbow') captainName = 'X-Bow';
            else if (selectedPlaystyle === 'drill') captainName = 'Goblin Drill';
            else if (selectedPlaystyle === 'wallbreakers') captainName = 'Wall Breakers';
            else if (selectedPlaystyle === 'giant') captainName = 'Giant';
            else if (selectedPlaystyle === 'egiant') captainName = 'Electro Giant';
            else if (selectedPlaystyle === 'bloon') captainName = 'Balloon';
            else if (selectedPlaystyle === 'mortar') captainName = 'Mortar';
            else if (selectedPlaystyle === 'rhogs') captainName = 'Royal Hogs';
            else if (selectedPlaystyle === '3m') captainName = 'Three Musketeers';

            // 1. Identify Captain to Keep (if any)
            const oldLen = builderDeck.length;
            if (captainName) {
              // Check if we have it
              const captainCard = all.find(c => c.name === captainName);
              const alreadyIn = builderDeck.find(c => c.name === captainName);

              if (captainCard && !alreadyIn) {
                console.log(`ðŸ‘¨â€âœˆï¸ Captain Found: ${captainName}. Adding to deck.`);
                builderDeck.push(captainCard);
                // Mark as used
                if (!cardUsageHistory[captainName]) cardUsageHistory[captainName] = 0;
                cardUsageHistory[captainName]++;
              }
              // Now, clear the rest of the deck, keeping only the captain if it was just added or already there.
              builderDeck = builderDeck.filter(c => c.name === captainName);
            } else {
              builderDeck = []; // Clear all if no specific captain
            }
            console.log(`Cleared ${oldLen} cards. Kept: ${builderDeck.length}`);

            // 3. Render Status
            renderBuilderUI();
            document.getElementById('aiStatus').textContent = "Regenerating with new rotation...";

            // 4. Run Autofill
            // Small delay to let UI allow repaint
            setTimeout(runExpertAutofill, 100);
          } else {
            // Normal mode (fill empty slots)
            runExpertAutofill();
          }
        });
      }

      function getDeckRoles(deck) {
        let winConCount = 0;
        let spellCount = 0;
        let hasSmallSpell = false;
        let hasBigSpell = false;
        let hasAirCounter = false;
        let hasBuilding = false;
        let buildingCount = 0;

        deck.forEach(c => {
          if (CARD_ROLES.winCon.includes(c.name)) winConCount++;
          if (CARD_ROLES.spellSmall.includes(c.name)) { spellCount++; hasSmallSpell = true; }
          if (CARD_ROLES.spellBig.includes(c.name)) { spellCount++; hasBigSpell = true; }
          if (CARD_ROLES.airCounter.includes(c.name)) hasAirCounter = true;
          if (CARD_ROLES.building.includes(c.name)) { hasBuilding = true; buildingCount++; }
        });

        return { winConCount, spellCount, hasSmallSpell, hasBigSpell, hasAirCounter, hasBuilding, buildingCount, hasWinCon: winConCount > 0 };
      }

      function getCardRole(name) {
        const roles = [];
        // Normalize name: Remove "Evolution" suffix if present to match base role
        // e.g. "Knight Evolution" -> "Knight"
        const cleanName = name.replace(/ Evolution$/i, '').trim();

        if (CARD_ROLES.winCon.includes(cleanName)) roles.push('winCon');
        if (CARD_ROLES.spellSmall.includes(cleanName)) roles.push('spellSmall');
        if (CARD_ROLES.spellBig.includes(cleanName)) roles.push('spellBig');
        if (CARD_ROLES.airCounter.includes(cleanName)) roles.push('airCounter');
        if (CARD_ROLES.building.includes(cleanName)) roles.push('building');
        if (CARD_ROLES.tankKiller.includes(cleanName)) roles.push('tankKiller');
        // CRITICAL MISSING CHECK ADDED:
        if (CARD_ROLES.miniTank.includes(cleanName)) roles.push('miniTank');

        return roles;
      }

      console.log('Main Script Ended');

      // --- CRITICAL RESTORATION: SUBSTITUTIONS & BUTTONS (Moved to Correct Scope) ---
      window.renderSubstitutions = function () {
        const grid = document.getElementById('subsGrid');
        if (!grid) return;
        grid.innerHTML = '';

        let pool = [];
        if (window.currentPlayerData && window.currentPlayerData.cards) {
          pool = window.currentPlayerData.cards;
        } else {
          pool = window.currentAppDeck ? [...window.currentAppDeck] : DEMO_DECK;
        }

        const inDeckNames = new Set((window.currentAppDeck || []).map(c => c.name));
        const candidates = pool.filter(c => !inDeckNames.has(c.name));
        candidates.sort((a, b) => (b.level || 0) - (a.level || 0));

        candidates.forEach(card => {
          const cardEl = buildCardElement(card); // Now accesses local buildCardElement correctly
          cardEl.style.cursor = 'pointer';
          cardEl.onclick = () => {
            const deck = window.currentAppDeck || [];
            if (deck.length < 8) {
              window.currentAppDeck.push(card);
              renderDeck({ currentDeck: window.currentAppDeck });
              alert(`Added ${card.name}`);
              document.getElementById('substitutionsModal').style.display = 'none';
              return;
            }
            if (confirm(`Replace a card with ${card.name}?`)) {
              window.currentAppDeck.pop();
              window.currentAppDeck.push(card);
              renderDeck({ currentDeck: window.currentAppDeck });
              document.getElementById('substitutionsModal').style.display = 'none';
            }
          };
          grid.appendChild(cardEl);
        });
      };

      // Wire up Substitutions Button
      const subBtnRef = document.getElementById('substitutionsBtn');
      if (subBtnRef) {
        subBtnRef.onclick = () => {
          window.renderSubstitutions();
          document.getElementById('substitutionsModal').style.display = 'flex';
        };
      }

      // Wire up Improve Deck Button (Green)
      const impBtn = document.getElementById('canImproveDeckBtn');
      if (impBtn && window.DeckWeakness) {
        impBtn.onclick = () => {
          // Use old logic if available or alert
          if (DeckWeakness.proposeFix) {
            const fix = DeckWeakness.proposeFix(window.currentAppDeck);
            if (fix) {
              alert(`Improvement Suggestion:\nSwap ${fix.remove.name} for ${fix.add.name}\n\nReason: ${fix.reason}`);
            } else {
              alert("Your deck looks solid! No obvious weaknesses found.");
            }
          } else {
            console.log("DeckWeakness.proposeFix not found in this version.");
          }
        }
      }
    })();
  </script>

  <!-- MATCHUP CONTROLLER SCRIPT (Dual Manual Mode) -->
  <script>
    (function () {
      console.log('--- Initializing Matchup Controller ---');
      // STATE
      let enemyDeck = [];
      // 'mine' or 'enemy'. Defaults to 'enemy' unless user explicitly clicks 'mine'
      let activeTarget = 'enemy';

      // DOM ELEMENTS
      const modal = document.getElementById('matchupModal');
      const openBtn = document.getElementById('matchupBtn');
      const closeBtn = document.getElementById('closeMatchup');

      const myDeckPreview = document.getElementById('myDeckPreview');
      const enemyDeckWrapper = document.getElementById('enemyDeckWrapper');

      const enemyPicker = document.getElementById('enemyCardPicker');
      const clearEnemyBtn = document.getElementById('clearEnemyBtn'); // Now clears ACTIVE deck
      const analyzeBtn = document.getElementById('analyzeBtn');
      const resultArea = document.getElementById('analysisResult');

      if (!analyzeBtn) {
        console.error("CRITICAL: analyzeBtn not found!");
        return;
      }

      // MODE SWITCHER UI (Dynamic)
      const modeHeader = document.createElement('div');
      modeHeader.style.cssText = 'grid-column: span 2; display: flex; gap: 10px; margin-bottom: 5px; justify-content: center;';

      // We will inject this mode switcher above the picker if we can locate options container?
      // Actually, let's just use click-to-edit logic on the decks themselves.
      // But explicit buttons are clearer.

      // OPEN MODAL
      if (openBtn) openBtn.onclick = async () => {
        console.log("Opening Matchup Modal");
        modal.style.display = 'flex';
        // SCROLL TO VIEW
        modal.scrollIntoView({ behavior: 'smooth' });

        // Ensure globals
        if (!window.builderDeck) window.builderDeck = [];

        // Default: If My Deck is empty, set focus to 'mine' first? No, usually 'enemy'.
        // Let's stick to 'enemy' default, but if My Deck is empty, user can click it.

        activeTarget = 'enemy';
        updateModeUI();

        renderMyDeck();
        renderEnemyDeck();

        // Load picker if empty
        if (enemyPicker.children.length === 0) {
          console.log("Loading cards for picker...");
          // Check if we have data, if not, fetch FULL LIST
          if (!window.currentPlayerData || !window.currentPlayerData.cards) {
            const status = document.createElement('div');
            status.textContent = 'Loading all cards...';
            status.style.textAlign = 'center';
            status.style.color = '#ccc';
            enemyPicker.appendChild(status);

            try {
              const res = await fetch('/api/cards');
              if (res.ok) {
                const cards = await res.json();
                if (!window.currentPlayerData) window.currentPlayerData = {};
                window.currentPlayerData.cards = cards;
                renderEnemyPicker();
              } else {
                enemyPicker.innerHTML = 'Failed to load cards.';
              }
            } catch (e) {
              console.error(e);
              enemyPicker.innerHTML = 'Error loading cards.';
            }
          } else {
            renderEnemyPicker();
          }
        }
      };

      // CLOSE MODAL
      if (closeBtn) closeBtn.onclick = () => {
        modal.style.display = 'none';
      };

      // HELPER: Visual Focus
      function updateModeUI() {
        // Highlight the active area
        if (activeTarget === 'mine') {
          myDeckPreview.style.borderColor = '#D4AF37'; // Gold
          myDeckPreview.style.boxShadow = '0 0 15px rgba(212,175,55, 0.4)';
          enemyDeckWrapper.style.borderColor = 'transparent';
          enemyDeckWrapper.style.boxShadow = 'none';
          // Update Clear Button Text
          clearEnemyBtn.textContent = 'Clear My Deck';
          // Picker Header
          // (Optional)
        } else {
          enemyDeckWrapper.style.borderColor = '#e74c3c'; // Red
          enemyDeckWrapper.style.boxShadow = '0 0 15px rgba(231, 76, 60, 0.4)';
          myDeckPreview.style.borderColor = 'transparent';
          myDeckPreview.style.boxShadow = 'none';
          clearEnemyBtn.textContent = 'Clear Enemy Deck';
        }
        // Re-render decks to update 'x' buttons
        renderMyDeck();
        renderEnemyDeck();
        updatePickerState();
      }

      // PROXY HELPER
      function getProxyImage(url) {
        if (!url) return '';
        if (url.startsWith('http')) {
          return `/api/proxy-image?src=${encodeURIComponent(url)}`;
        }
        return url;
      }

      // RENDER YOUR DECK
      function renderMyDeck() {
        myDeckPreview.innerHTML = '';
        myDeckPreview.className = 'deck-grid'; // Use shared 4x2 grid class
        // Add border styling for focus indication
        myDeckPreview.style.border = '2px solid transparent';
        myDeckPreview.style.borderRadius = '8px';
        myDeckPreview.style.padding = '5px';
        myDeckPreview.style.cursor = 'pointer';
        myDeckPreview.onclick = () => { activeTarget = 'mine'; updateModeUI(); };

        const currentDeck = window.builderDeck || [];

        // If empty, fill with placeholders
        for (let i = 0; i < 8; i++) {
          const card = currentDeck[i];
          const div = document.createElement('div');
          div.style.position = 'relative';

          if (card) {
            const img = document.createElement('img');
            img.src = getProxyImage(card.iconUrls?.medium || card.iconUrl);
            img.style.width = '100%';
            img.style.borderRadius = '4px';
            img.title = card.name || "Card";
            div.appendChild(img);

            // Remove X button (only if active?)
            if (activeTarget === 'mine') {
              const xBtn = document.createElement('div');
              xBtn.innerHTML = 'Ã—';
              xBtn.style.cssText = 'position:absolute; top:-5px; right:-5px; background:red; color:white; border-radius:50%; width:18px; height:18px; text-align:center; line-height:16px; cursor:pointer; font-weight:bold; font-size:14px; box-shadow:0 2px 5px black;';
              xBtn.onclick = (e) => {
                e.stopPropagation();
                window.builderDeck.splice(i, 1);
                renderMyDeck();
                updatePickerState(); // Update picker after removing
                if (window.renderDeck) window.renderDeck({ currentDeck: window.builderDeck }); // Update main UI
              };
              div.appendChild(xBtn);
            }
          } else {
            // Empty Slot
            div.className = 'empty-slot';
            div.style.width = '100%'; // Fit grid
            div.style.height = 'auto'; // Aspect ratio handled by grid/content
            div.style.aspectRatio = '0.7';
            div.innerHTML = '+';
            div.style.fontSize = '24px';
            div.style.border = '2px dashed #444';
            div.style.borderRadius = '6px';
            div.style.display = 'flex';
            div.style.alignItems = 'center';
            div.style.justifyContent = 'center';
            div.style.color = '#666';
          }
          myDeckPreview.appendChild(div);
        }
      }

      // RENDER ENEMY DECK
      function renderEnemyDeck() {
        enemyDeckWrapper.innerHTML = '';

        // CSS Grid Layout applied inline here or via class
        enemyDeckWrapper.className = 'deck-grid'; // Use shared 4x2 grid class

        enemyDeckWrapper.style.border = '2px solid transparent';
        enemyDeckWrapper.style.borderRadius = '8px';
        enemyDeckWrapper.style.padding = '5px';
        enemyDeckWrapper.style.cursor = 'pointer';
        enemyDeckWrapper.onclick = () => { activeTarget = 'enemy'; updateModeUI(); };

        for (let i = 0; i < 8; i++) {
          const c = enemyDeck[i];
          const div = document.createElement('div');
          div.style.position = 'relative';

          if (c) {
            const img = document.createElement('img');
            img.src = getProxyImage(c.iconUrls?.medium || c.iconUrl);
            img.style.width = '100%';
            img.style.borderRadius = '4px';
            img.style.cursor = 'pointer';
            div.appendChild(img);

            // Remove logic
            if (activeTarget === 'enemy') {
              const xBtn = document.createElement('div');
              xBtn.innerHTML = 'Ã—';
              xBtn.style.cssText = 'position:absolute; top:-5px; right:-5px; background:red; color:white; border-radius:50%; width:18px; height:18px; text-align:center; line-height:16px; cursor:pointer; font-weight:bold; font-size:14px; box-shadow:0 2px 5px black;';
              xBtn.onclick = (e) => {
                e.stopPropagation();
                enemyDeck.splice(i, 1);
                renderEnemyDeck();
                updatePickerState();
              };
              div.appendChild(xBtn);
            }
          } else {
            // Empty
            div.className = 'empty-slot';
            div.style.width = '100%';
            div.style.height = 'auto';
            div.style.aspectRatio = '0.7';
            div.innerHTML = '+';
            div.style.border = '2px dashed #444';
            div.style.borderRadius = '6px';
            div.style.display = 'flex';
            div.style.alignItems = 'center';
            div.style.justifyContent = 'center';
            div.style.color = '#666';
          }
          enemyDeckWrapper.appendChild(div);
        }
      }

      // RENDER PICKER
      function renderEnemyPicker() {
        enemyPicker.innerHTML = '';
        const sourceCards = window.currentPlayerData?.cards || [];

        if (sourceCards.length === 0) {
          enemyPicker.innerHTML = '<div style="color:#aaa; text-align:center; padding:20px;">No cards found.</div>';
          return;
        }

        const cards = [...sourceCards].sort((a, b) => (a.elixirCost || 0) - (b.elixirCost || 0));

        cards.forEach(c => {
          const img = document.createElement('img');
          img.src = getProxyImage(c.iconUrls?.medium || c.iconUrl);
          img.className = 'picker-card';
          img.title = c.name;
          img.loading = 'lazy';

          img.onclick = () => {
            // Logic depends on activeTarget
            if (activeTarget === 'mine') {
              if (window.builderDeck.length < 8 && !window.builderDeck.find(x => x.name === c.name)) {
                window.builderDeck.push(c);
                renderMyDeck();
                updatePickerState();
                // Also notify global script? We are mutating direct global reference.
                // Might need to update main UI? 
                // Since modal is open, we can defer main UI update or trigger it.
                if (window.renderDeck) window.renderDeck({ currentDeck: window.builderDeck });
              }
            } else {
              if (enemyDeck.length < 8 && !enemyDeck.find(x => x.name === c.name)) {
                enemyDeck.push(c);
                renderEnemyDeck();
                updatePickerState();
              }
            }
          };
          enemyPicker.appendChild(img);
        });

        updatePickerState();
      }

      function updatePickerState() {
        // Dim selected cards based on ACTIVE TARGET
        const targetDeck = (activeTarget === 'mine') ? window.builderDeck : enemyDeck;

        Array.from(enemyPicker.children).forEach(img => {
          const cardName = img.title;
          // Check if card is in the active target deck
          const isInActiveDeck = targetDeck.find(c => c.name === cardName);

          // We NO LONGER check isInOtherDeck, because user wants to allow same card in both decks.

          if (isInActiveDeck || targetDeck.length >= 8) {
            img.style.opacity = '0.3';
            img.style.pointerEvents = 'none';
          } else {
            img.style.opacity = '1';
            img.style.pointerEvents = 'auto';
          }
        });
      }

      // CLEAR BUTTON
      clearEnemyBtn.onclick = () => {
        if (activeTarget === 'mine') {
          window.builderDeck = [];
          renderMyDeck();
          if (window.renderDeck) window.renderDeck({ currentDeck: [] });
        } else {
          enemyDeck = [];
          renderEnemyDeck();
        }
        updatePickerState();
        resultArea.style.display = 'none';
      };

      // ANALYZE
      analyzeBtn.onclick = () => {
        if (!window.MatchupAnalyzer) {
          alert("Matchup Analyzer not loaded yet!");
          return;
        }
        // Use Global builderDeck directly
        const myDeck = window.builderDeck || [];

        if (myDeck.length < 8) {
          alert("Your deck is incomplete! Please select 8 cards.");
          return;
        }
        if (enemyDeck.length < 8) {
          alert("Enemy deck is incomplete! Please select 8 cards.");
          return;
        }

        const result = window.MatchupAnalyzer.analyzeMatchup(myDeck, enemyDeck);

        // RENDER RESULT
        const advantage = result.advantage; // -10 to +10 roughly

        let barColor = '#3498db'; // blue
        let advText = "Even";
        if (advantage > 2) { barColor = '#2ecc71'; advText = "Advantage: YOU"; }
        if (advantage < -2) { barColor = '#e74c3c'; advText = "Advantage: ENEMY"; }

        // Clamp for bar display (50% is 0)
        let pct = 50 + (advantage * 4);
        if (pct < 10) pct = 10;
        if (pct > 90) pct = 90;

        resultArea.innerHTML = `
           <div style="font-size:24px; font-weight:bold; margin-bottom:15px; text-align:center; color:${barColor}">
              ${advText} (${advantage > 0 ? '+' : ''}${advantage})
           </div>
           
           <div style="background:#444; height:20px; border-radius:10px; width:100%; position:relative; overflow:hidden; margin-bottom:20px;">
              <div style="position:absolute; left:50%; top:0; bottom:0; width:2px; background:white; z-index:2; opacity:0.5;"></div>
              <div style="background:${barColor}; width:${pct}%; height:100%; transition: width 0.5s;"></div>
           </div>

           <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px;">
              <div style="background:rgba(0,0,0,0.3); padding:15px; border-radius:8px;">
                 <h4 style="color:#e74c3c; margin-top:0;">âš ï¸ Threats to You</h4>
                 <ul style="padding-left:20px; margin:0; color:#ddd;">
                    ${result.threats && result.threats.length ? result.threats.map(t => `<li>${t}</li>`).join('') : '<li style="color:#888">None detected</li>'}
                 </ul>
              </div>
              <div style="background:rgba(0,0,0,0.3); padding:15px; border-radius:8px;">
                 <h4 style="color:#2ecc71; margin-top:0;">ðŸ’¡ Strategy Tips</h4>
                 <ul style="padding-left:20px; margin:0; color:#ddd;">
                    ${result.tips && result.tips.length ? result.tips.map(t => `<li>${t}</li>`).join('') : '<li style="color:#888">Play smart!</li>'}
                 </ul>
              </div>
           </div>
           
           <div style="margin-top:20px; font-size:14px; color:#aaa; text-align:center;">
             Avg Elixir: You <b>${result.myAvg}</b> vs Enemy <b>${result.enemyAvg}</b>
           </div>
        `;
        resultArea.style.display = 'block';
        resultArea.scrollIntoView({ behavior: 'smooth' });
      };

      console.log('Matchup Analyzer Script Loaded (Dual Manual Mode)');

      // --- CRITICAL RESTORATION: SUBSTITUTIONS & BUTTONS ---
      // This logic was missing in the reverted commit but is required for buttons to work.



      // Expose Globals



    })();
  </script>
  <script type="module">
    import { WIN_CONDITION_GUIDES } from './win_conditions.js';
    window.WIN_CONDITION_GUIDES = WIN_CONDITION_GUIDES;
    console.log("Win Conditions Loaded:", Object.keys(WIN_CONDITION_GUIDES).length);
  </script>
</body>

</html>